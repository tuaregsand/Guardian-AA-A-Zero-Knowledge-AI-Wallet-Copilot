{"version":3,"sources":["../../src/types/index.ts","../../src/zk/types.ts","../../src/zk/prover.ts","../../src/zk/verifier.ts","../../src/zk/client.ts"],"names":["z","sha256"],"mappings":"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","file":"index.mjs","sourcesContent":["import { z } from 'zod';\n\n// ============================================================================\n// ZK Proof Types\n// ============================================================================\n\n/**\n * Schema for ZK proof output from the Halo2 circuit\n */\nexport const ZkProofOutputSchema = z.object({\n  /** Length of the original input data */\n  len: z.number().int().nonnegative(),\n  /** SHA256 hash of the input as 32-byte array */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n});\n\nexport type ZkProofOutput = z.infer<typeof ZkProofOutputSchema>;\n\n/**\n * Schema for ZK proof generation result with proof bytes\n */\nexport const ZkProofResultSchema = z.object({\n  /** SHA256 hash of the input */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n  /** Serialized proof bytes */\n  proof: z.instanceof(Uint8Array),\n  /** Proof generation time in milliseconds */\n  generationTime: z.number().int().nonnegative(),\n});\n\nexport type ZkProofResult = z.infer<typeof ZkProofResultSchema>;\n\n/**\n * Configuration for ZK proof generation\n */\nexport const ZkProofConfigSchema = z.object({\n  /** Circuit size parameter (k value) */\n  circuitK: z.number().int().min(10).max(20).default(14),\n  /** Whether to use cached proving keys */\n  useCachedKeys: z.boolean().default(true),\n  /** Timeout for proof generation in milliseconds */\n  timeout: z.number().int().positive().default(30000),\n});\n\nexport type ZkProofConfig = z.infer<typeof ZkProofConfigSchema>;\n\n// ============================================================================\n// Account Abstraction Types (ERC-4337)\n// ============================================================================\n\n/**\n * Schema for UserOperation as defined in ERC-4337\n */\nexport const UserOperationSchema = z.object({\n  sender: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  nonce: z.bigint(),\n  initCode: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callGasLimit: z.bigint(),\n  verificationGasLimit: z.bigint(),\n  preVerificationGas: z.bigint(),\n  maxFeePerGas: z.bigint(),\n  maxPriorityFeePerGas: z.bigint(),\n  paymasterAndData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  signature: z.string().regex(/^0x[a-fA-F0-9]*$/),\n});\n\nexport type UserOperation = z.infer<typeof UserOperationSchema>;\n\n/**\n * Schema for account configuration\n */\nexport const AccountConfigSchema = z.object({\n  /** Account implementation address */\n  implementation: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Account factory address */\n  factory: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Entry point address */\n  entryPoint: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Initial account owner */\n  owner: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Salt for deterministic address generation */\n  salt: z.bigint().default(0n),\n});\n\nexport type AccountConfig = z.infer<typeof AccountConfigSchema>;\n\n/**\n * Schema for multi-signature account configuration\n */\nexport const MultiSigConfigSchema = z.object({\n  /** List of signer addresses */\n  signers: z.array(z.string().regex(/^0x[a-fA-F0-9]{40}$/)).min(1),\n  /** Required number of signatures (threshold) */\n  threshold: z.number().int().positive(),\n  /** Delay for signer management operations in seconds */\n  delay: z.number().int().nonnegative().default(0),\n});\n\nexport type MultiSigConfig = z.infer<typeof MultiSigConfigSchema>;\n\n/**\n * Schema for paymaster configuration\n */\nexport const PaymasterConfigSchema = z.object({\n  /** Paymaster contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Verifying signer for paymaster */\n  signer: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Valid until timestamp */\n  validUntil: z.number().int().nonnegative(),\n  /** Valid after timestamp */\n  validAfter: z.number().int().nonnegative(),\n});\n\nexport type PaymasterConfig = z.infer<typeof PaymasterConfigSchema>;\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\n/**\n * Schema for transaction data\n */\nexport const TransactionDataSchema = z.object({\n  /** Target contract address */\n  to: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Value in wei */\n  value: z.bigint().default(0n),\n  /** Call data */\n  data: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Operation type (0 = call, 1 = delegatecall) */\n  operation: z.number().int().min(0).max(1).default(0),\n});\n\nexport type TransactionData = z.infer<typeof TransactionDataSchema>;\n\n/**\n * Schema for batch transaction\n */\nexport const BatchTransactionSchema = z.object({\n  /** Array of transaction data */\n  transactions: z.array(TransactionDataSchema).min(1),\n  /** Whether to fail on first error */\n  failOnError: z.boolean().default(true),\n});\n\nexport type BatchTransaction = z.infer<typeof BatchTransactionSchema>;\n\n// ============================================================================\n// Network Types\n// ============================================================================\n\n/**\n * Schema for network configuration\n */\nexport const NetworkConfigSchema = z.object({\n  /** Chain ID */\n  chainId: z.number().int().positive(),\n  /** Network name */\n  name: z.string().min(1),\n  /** RPC URL */\n  rpcUrl: z.string().url(),\n  /** Block explorer URL */\n  explorerUrl: z.string().url().optional(),\n  /** Native currency symbol */\n  currency: z.string().min(1).default('ETH'),\n  /** Whether this is a testnet */\n  isTestnet: z.boolean().default(false),\n});\n\nexport type NetworkConfig = z.infer<typeof NetworkConfigSchema>;\n\n// ============================================================================\n// SDK Configuration Types\n// ============================================================================\n\n/**\n * Schema for SDK configuration\n */\nexport const SdkConfigSchema = z.object({\n  /** Network configuration */\n  network: NetworkConfigSchema,\n  /** ZK proof configuration */\n  zkConfig: ZkProofConfigSchema.optional(),\n  /** Account configuration */\n  accountConfig: AccountConfigSchema.optional(),\n  /** Paymaster configuration */\n  paymasterConfig: PaymasterConfigSchema.optional(),\n  /** Enable debug logging */\n  debug: z.boolean().default(false),\n});\n\nexport type SdkConfig = z.infer<typeof SdkConfigSchema>;\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/**\n * Base error class for Guardian-AA SDK\n */\nexport class GuardianAAError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'GuardianAAError';\n  }\n}\n\n/**\n * ZK proof related errors\n */\nexport class ZkProofError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'ZK_PROOF_ERROR', details);\n    this.name = 'ZkProofError';\n  }\n}\n\n/**\n * Contract interaction errors\n */\nexport class ContractError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONTRACT_ERROR', details);\n    this.name = 'ContractError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Result type for operations that can fail\n */\nexport type Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\n/**\n * Async result type\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>;\n\n/**\n * Hex string type\n */\nexport type HexString = `0x${string}`;\n\n/**\n * Address type (20-byte hex string)\n */\nexport type Address = `0x${string}`;\n\n/**\n * Bytes32 type (32-byte hex string)\n */\nexport type Bytes32 = `0x${string}`;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Default gas limits for various operations\n */\nexport const DEFAULT_GAS_LIMITS = {\n  VERIFICATION: 70000n,\n  CALL: 35000n,\n  CREATION: 1000000n,\n  PRE_VERIFICATION: 21000n,\n} as const;\n\n/**\n * Supported chain IDs\n */\nexport const SUPPORTED_CHAINS = {\n  ETHEREUM_MAINNET: 1,\n  ETHEREUM_SEPOLIA: 11155111,\n  POLYGON_MAINNET: 137,\n  POLYGON_MUMBAI: 80001,\n  ARBITRUM_ONE: 42161,\n  ARBITRUM_SEPOLIA: 421614,\n  OPTIMISM_MAINNET: 10,\n  OPTIMISM_SEPOLIA: 11155420,\n} as const;\n\n/**\n * Contract addresses for different chains\n */\nexport type ContractAddresses = {\n  entryPoint: Address;\n  accountFactory: Address;\n  multiSigFactory: Address;\n  verifyingPaymaster: Address;\n};\n\nexport const CONTRACT_ADDRESSES: Record<number, ContractAddresses> = {\n  // Ethereum Sepolia\n  [SUPPORTED_CHAINS.ETHEREUM_SEPOLIA]: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n    accountFactory: '0x9406Cc6185a346906296840746125a0E44976454',\n    multiSigFactory: '0x000000000000000000000000000000000000dEaD',\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD',\n  },\n  // Add more chains as needed\n}; ","import { z } from 'zod';\n\n/**\n * FFI interface types for the Rust prover\n */\nexport interface FFIInput {\n  data: Uint8Array;\n  len: number;\n}\n\nexport interface FFIOutput {\n  len: number;\n  hash: number[];\n}\n\n/**\n * Prover performance metrics\n */\nexport const ProverMetricsSchema = z.object({\n  setupTime: z.number().nonnegative(),\n  proofTime: z.number().nonnegative(),\n  verificationTime: z.number().nonnegative(),\n  proofSize: z.number().int().nonnegative(),\n  circuitSize: z.number().int().nonnegative(),\n});\n\nexport type ProverMetrics = z.infer<typeof ProverMetricsSchema>;\n\n/**\n * Proof verification status\n */\nexport const VerificationStatusSchema = z.enum([\n  'VALID',\n  'INVALID', \n  'ERROR',\n  'TIMEOUT',\n]);\n\nexport type VerificationStatus = z.infer<typeof VerificationStatusSchema>;\n\n/**\n * Proof verification result\n */\nexport const VerificationResultSchema = z.object({\n  status: VerificationStatusSchema,\n  message: z.string().optional(),\n  verificationTime: z.number().nonnegative().optional(),\n  publicInputsHash: z.string().optional(),\n});\n\nexport type VerificationResult = z.infer<typeof VerificationResultSchema>;\n\n/**\n * Prover configuration extending base ZkProofConfig\n */\nexport const ProverConfigSchema = z.object({\n  circuitK: z.number().int().min(10).max(20).default(14),\n  useCachedKeys: z.boolean().default(true),\n  timeout: z.number().int().positive().default(30000),\n  maxInputSize: z.number().int().positive().default(1024 * 1024), // 1MB\n  enableBenchmarking: z.boolean().default(false),\n  logLevel: z.enum(['ERROR', 'WARN', 'INFO', 'DEBUG']).default('INFO'),\n});\n\nexport type ProverConfig = z.infer<typeof ProverConfigSchema>;\n\n/**\n * Proving key cache information\n */\nexport const ProvingKeyCacheSchema = z.object({\n  circuitK: z.number().int(),\n  keyHash: z.string(),\n  createdAt: z.number().int(),\n  size: z.number().int(),\n  isValid: z.boolean(),\n});\n\nexport type ProvingKeyCache = z.infer<typeof ProvingKeyCacheSchema>;\n\n/**\n * Circuit statistics\n */\nexport const CircuitStatsSchema = z.object({\n  numConstraints: z.number().int().nonnegative(),\n  numAdvice: z.number().int().nonnegative(),\n  numFixed: z.number().int().nonnegative(),\n  numInstance: z.number().int().nonnegative(),\n  degree: z.number().int().nonnegative(),\n});\n\nexport type CircuitStats = z.infer<typeof CircuitStatsSchema>;\n\n/**\n * Proof batch for multiple inputs\n */\nexport const ProofBatchSchema = z.object({\n  inputs: z.array(z.instanceof(Uint8Array)).min(1),\n  parallelization: z.boolean().default(true),\n  batchId: z.string().optional(),\n});\n\nexport type ProofBatch = z.infer<typeof ProofBatchSchema>;\n\n/**\n * Batch proof result\n */\nexport const BatchProofResultSchema = z.object({\n  batchId: z.string().optional(),\n  results: z.array(z.object({\n    index: z.number().int().nonnegative(),\n    hash: z.array(z.number().int().min(0).max(255)).length(32),\n    proof: z.instanceof(Uint8Array),\n    generationTime: z.number().nonnegative(),\n  })),\n  totalTime: z.number().nonnegative(),\n  averageTime: z.number().nonnegative(),\n});\n\nexport type BatchProofResult = z.infer<typeof BatchProofResultSchema>;\n\n/**\n * Constants for ZK operations\n */\nexport const ZK_CONSTANTS = {\n  MAX_CIRCUIT_K: 20,\n  MIN_CIRCUIT_K: 10,\n  DEFAULT_CIRCUIT_K: 14,\n  MAX_INPUT_SIZE: 1024 * 1024, // 1MB\n  SHA256_HASH_SIZE: 32,\n  TARGET_PROOF_TIME_MS: 500,\n  MAX_PROOF_TIME_MS: 30000,\n  PROOF_CACHE_TTL_MS: 24 * 60 * 60 * 1000, // 24 hours\n} as const;\n\n/**\n * Error codes specific to ZK operations\n */\nexport const ZK_ERROR_CODES = {\n  PROVER_NOT_INITIALIZED: 'PROVER_NOT_INITIALIZED',\n  INVALID_INPUT_SIZE: 'INVALID_INPUT_SIZE',\n  PROOF_GENERATION_FAILED: 'PROOF_GENERATION_FAILED',\n  VERIFICATION_FAILED: 'VERIFICATION_FAILED',\n  TIMEOUT_EXCEEDED: 'TIMEOUT_EXCEEDED',\n  INVALID_CIRCUIT_K: 'INVALID_CIRCUIT_K',\n  PROVING_KEY_NOT_FOUND: 'PROVING_KEY_NOT_FOUND',\n  FFI_ERROR: 'FFI_ERROR',\n} as const;\n\nexport type ZkErrorCode = keyof typeof ZK_ERROR_CODES; ","import { sha256 } from '@noble/hashes/sha256';\nimport { ZkProofError } from '../types';\nimport {\n  ProverConfig,\n  ProverConfigSchema,\n  ProverMetrics,\n  ZK_CONSTANTS,\n  ZK_ERROR_CODES,\n  ProofBatch,\n  BatchProofResult,\n} from './types';\n\n/**\n * ZK Prover class that interfaces with the Rust guardian_zkml library\n */\nexport class ZkProver {\n  private config: ProverConfig;\n  private isInitialized = false;\n  private setupTime = 0;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.config = ProverConfigSchema.parse(config);\n  }\n\n  /**\n   * Initialize the prover (setup proving keys, etc.)\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // In a real implementation, this would load the Rust WASM module\n      // or initialize FFI bindings to the guardian_zkml library\n      await this.setupProvingSystem();\n      \n      this.setupTime = performance.now() - startTime;\n      this.isInitialized = true;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Prover initialization', this.setupTime);\n      }\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK prover',\n        { error, config: this.config }\n      );\n    }\n  }\n\n  /**\n   * Generate a ZK proof for the given input data\n   */\n  async generateProof(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n    generationTime: number;\n  }> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Prover not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    if (input.length > this.config.maxInputSize) {\n      throw new ZkProofError(\n        `Input size ${input.length} exceeds maximum ${this.config.maxInputSize}`,\n        { code: ZK_ERROR_CODES.INVALID_INPUT_SIZE }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // For now, we'll simulate the proof generation\n      // In the real implementation, this would call the Rust FFI\n      const result = await this.callRustProver(input);\n      \n      const generationTime = performance.now() - startTime;\n\n      if (generationTime > ZK_CONSTANTS.TARGET_PROOF_TIME_MS) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Proof generation time ${generationTime}ms exceeds target ${ZK_CONSTANTS.TARGET_PROOF_TIME_MS}ms`\n        );\n      }\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof generation', generationTime);\n      }\n\n      return {\n        hash: result.hash,\n        proof: result.proof,\n        generationTime,\n      };\n    } catch (error) {\n      throw new ZkProofError(\n        'Proof generation failed',\n        { error, inputSize: input.length }\n      );\n    }\n  }\n\n  /**\n   * Generate proofs for multiple inputs in batch\n   */\n  async generateBatchProofs(batch: ProofBatch): Promise<BatchProofResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Prover not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n    const results = [];\n\n    try {\n      if (batch.parallelization) {\n        // Generate proofs in parallel\n        const promises = batch.inputs.map(async (input, index) => {\n          const result = await this.generateProof(input);\n          return { index, ...result };\n        });\n\n        const parallelResults = await Promise.all(promises);\n        results.push(...parallelResults);\n      } else {\n        // Generate proofs sequentially\n        for (let i = 0; i < batch.inputs.length; i += 1) {\n          const result = await this.generateProof(batch.inputs[i]!);\n          results.push({ index: i, ...result });\n        }\n      }\n\n      const totalTime = performance.now() - startTime;\n      const averageTime = totalTime / batch.inputs.length;\n\n      return {\n        batchId: batch.batchId,\n        results,\n        totalTime,\n        averageTime,\n      };\n    } catch (error) {\n      throw new ZkProofError(\n        'Batch proof generation failed',\n        { error, batchSize: batch.inputs.length }\n      );\n    }\n  }\n\n  /**\n   * Get prover performance metrics\n   */\n  getMetrics(): ProverMetrics {\n    return {\n      setupTime: this.setupTime,\n      proofTime: 0, // Would be calculated from actual measurements\n      verificationTime: 0,\n      proofSize: 0,\n      circuitSize: 2 ** this.config.circuitK,\n    };\n  }\n\n  /**\n   * Update prover configuration\n   */\n  updateConfig(newConfig: Partial<ProverConfig>): void {\n    const updatedConfig = { ...this.config, ...newConfig };\n    this.config = ProverConfigSchema.parse(updatedConfig);\n  }\n\n  /**\n   * Check if prover is initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    // In real implementation, this would clean up FFI resources\n    this.isInitialized = false;\n    this.setupTime = 0;\n  }\n\n  /**\n   * Private method to setup the proving system\n   */\n  private async setupProvingSystem(): Promise<void> {\n    // Simulate proving system setup\n    // In real implementation, this would:\n    // 1. Load or generate proving keys\n    // 2. Initialize the Halo2 circuit\n    // 3. Setup universal SRS if needed\n    \n    await this.delay(100); // Simulate setup time\n  }\n\n  /**\n   * Private method to call the Rust prover via FFI\n   */\n  private async callRustProver(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n  }> {\n    // Simulate the actual FFI call to guardian_zkml\n    // In real implementation, this would:\n    // 1. Convert JS Uint8Array to FFI-compatible format\n    // 2. Call the Rust generate_proof_with_proof function\n    // 3. Convert the result back to JS types\n\n    // For now, compute the actual SHA256 hash\n    const hashBuffer = sha256(input);\n    const hash = Array.from(hashBuffer);\n\n    // Simulate proof bytes (in real implementation, this comes from Halo2)\n    const proof = new Uint8Array(1024); // Typical Halo2 proof size\n    crypto.getRandomValues(proof);\n\n    // Simulate proof generation time\n    await this.delay(50);\n\n    return { hash, proof };\n  }\n\n  /**\n   * Utility method for simulating async operations\n   */\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  /**\n   * Log performance metrics\n   */\n  private logPerformance(operation: string, timeMs: number): void {\n    if (this.config.logLevel === 'DEBUG' || this.config.logLevel === 'INFO') {\n      // eslint-disable-next-line no-console\n      console.log(`[ZkProver] ${operation}: ${timeMs.toFixed(2)}ms`);\n    }\n  }\n} ","import { sha256 } from '@noble/hashes/sha256';\nimport { ZkProofError } from '../types';\nimport {\n  VerificationResult,\n  VerificationStatus,\n  ProverConfig,\n  ZK_ERROR_CODES,\n} from './types';\n\n/**\n * ZK Verifier class for verifying zero-knowledge proofs\n */\nexport class ZkVerifier {\n  private config: ProverConfig;\n  private isInitialized = false;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.config = {\n      circuitK: 14,\n      useCachedKeys: true,\n      timeout: 30000,\n      maxInputSize: 1024 * 1024,\n      enableBenchmarking: false,\n      logLevel: 'INFO',\n      ...config,\n    };\n  }\n\n  /**\n   * Initialize the verifier\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // In real implementation, this would load verifying keys\n      await this.setupVerificationSystem();\n      this.isInitialized = true;\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK verifier',\n        { error, config: this.config }\n      );\n    }\n  }\n\n  /**\n   * Verify a ZK proof against the original input\n   */\n  async verifyProof(\n    input: Uint8Array,\n    proof: Uint8Array,\n    expectedHash: number[]\n  ): Promise<VerificationResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // First, verify the hash matches\n      const computedHashBuffer = sha256(input);\n      const computedHash = Array.from(computedHashBuffer);\n\n      if (!this.arraysEqual(computedHash, expectedHash)) {\n        return {\n          status: 'INVALID' as VerificationStatus,\n          message: 'Hash mismatch',\n          verificationTime: performance.now() - startTime,\n        };\n      }\n\n      // In real implementation, this would verify the ZK proof\n      const isValidProof = await this.verifyZkProof(proof, expectedHash);\n      const verificationTime = performance.now() - startTime;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof verification', verificationTime);\n      }\n\n      return {\n        status: isValidProof ? 'VALID' : 'INVALID',\n        verificationTime,\n        publicInputsHash: this.arrayToHex(expectedHash),\n      };\n    } catch (error) {\n      return {\n        status: 'ERROR' as VerificationStatus,\n        message: error instanceof Error ? error.message : 'Unknown error',\n        verificationTime: performance.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Verify only the proof (without re-computing the hash)\n   */\n  async verifyProofOnly(\n    proof: Uint8Array,\n    publicInputs: number[]\n  ): Promise<VerificationResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      const isValid = await this.verifyZkProof(proof, publicInputs);\n      const verificationTime = performance.now() - startTime;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof-only verification', verificationTime);\n      }\n\n      return {\n        status: isValid ? 'VALID' : 'INVALID',\n        verificationTime,\n        publicInputsHash: this.arrayToHex(publicInputs),\n      };\n    } catch (error) {\n      return {\n        status: 'ERROR' as VerificationStatus,\n        message: error instanceof Error ? error.message : 'Unknown error',\n        verificationTime: performance.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Batch verify multiple proofs\n   */\n  async verifyBatchProofs(\n    proofs: Array<{\n      input: Uint8Array;\n      proof: Uint8Array;\n      expectedHash: number[];\n    }>\n  ): Promise<VerificationResult[]> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const promises = proofs.map(({ input, proof, expectedHash }) =>\n      this.verifyProof(input, proof, expectedHash)\n    );\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Check if verifier is ready\n   */\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    this.isInitialized = false;\n  }\n\n  /**\n   * Private method to setup verification system\n   */\n  private async setupVerificationSystem(): Promise<void> {\n    // Simulate verification system setup\n    // In real implementation, this would load verifying keys\n    await this.delay(50);\n  }\n\n  /**\n   * Private method to verify the ZK proof\n   */\n  private async verifyZkProof(\n    proof: Uint8Array,\n    publicInputs: number[]\n  ): Promise<boolean> {\n    // Simulate ZK proof verification\n    // In real implementation, this would:\n    // 1. Call the Rust verify_proof_with_proof function\n    // 2. Use the loaded verifying key and public inputs\n    // 3. Return the verification result\n\n    await this.delay(10); // Simulate verification time\n\n    // For demonstration, we'll do a basic check\n    return proof.length > 0 && publicInputs.length === 32;\n  }\n\n  /**\n   * Utility method to compare arrays\n   */\n  private arraysEqual(a: number[], b: number[]): boolean {\n    if (a.length !== b.length) return false;\n    return a.every((val, index) => val === b[index]);\n  }\n\n  /**\n   * Convert number array to hex string\n   */\n  private arrayToHex(arr: number[]): string {\n    return `0x${arr.map((b) => b.toString(16).padStart(2, '0')).join('')}`;\n  }\n\n  /**\n   * Utility method for simulating async operations\n   */\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  /**\n   * Log performance metrics\n   */\n  private logPerformance(operation: string, timeMs: number): void {\n    if (this.config.logLevel === 'DEBUG' || this.config.logLevel === 'INFO') {\n      // eslint-disable-next-line no-console\n      console.log(`[ZkVerifier] ${operation}: ${timeMs.toFixed(2)}ms`);\n    }\n  }\n} ","import { ZkProver } from './prover';\nimport { ZkVerifier } from './verifier';\nimport { ZkProofError } from '../types';\nimport {\n  ProverConfig,\n  VerificationResult,\n  ProofBatch,\n  BatchProofResult,\n  ZK_ERROR_CODES,\n} from './types';\n\n/**\n * High-level ZK client that combines prover and verifier functionality\n */\nexport class ZkClient {\n  private prover: ZkProver;\n  private verifier: ZkVerifier;\n  private isInitialized = false;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.prover = new ZkProver(config);\n    this.verifier = new ZkVerifier(config);\n  }\n\n  /**\n   * Initialize both prover and verifier\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      await Promise.all([\n        this.prover.initialize(),\n        this.verifier.initialize(),\n      ]);\n      this.isInitialized = true;\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK client',\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Generate a proof for input data\n   */\n  async generateProof(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n    generationTime: number;\n  }> {\n    this.ensureInitialized();\n    return this.prover.generateProof(input);\n  }\n\n  /**\n   * Verify a proof against the original input\n   */\n  async verifyProof(\n    input: Uint8Array,\n    proof: Uint8Array,\n    expectedHash: number[]\n  ): Promise<VerificationResult> {\n    this.ensureInitialized();\n    return this.verifier.verifyProof(input, proof, expectedHash);\n  }\n\n  /**\n   * Generate and verify a proof in one operation\n   */\n  async proveAndVerify(input: Uint8Array): Promise<{\n    proof: {\n      hash: number[];\n      proof: Uint8Array;\n      generationTime: number;\n    };\n    verification: VerificationResult;\n  }> {\n    this.ensureInitialized();\n\n    const proof = await this.generateProof(input);\n    const verification = await this.verifyProof(\n      input,\n      proof.proof,\n      proof.hash\n    );\n\n    return { proof, verification };\n  }\n\n  /**\n   * Generate proofs for multiple inputs\n   */\n  async generateBatchProofs(batch: ProofBatch): Promise<BatchProofResult> {\n    this.ensureInitialized();\n    return this.prover.generateBatchProofs(batch);\n  }\n\n  /**\n   * Verify multiple proofs\n   */\n  async verifyBatchProofs(\n    proofs: Array<{\n      input: Uint8Array;\n      proof: Uint8Array;\n      expectedHash: number[];\n    }>\n  ): Promise<VerificationResult[]> {\n    this.ensureInitialized();\n    return this.verifier.verifyBatchProofs(proofs);\n  }\n\n  /**\n   * Get performance metrics from the prover\n   */\n  getMetrics(): {\n    setupTime: number;\n    proofTime: number;\n    verificationTime: number;\n    proofSize: number;\n    circuitSize: number;\n  } {\n    this.ensureInitialized();\n    return this.prover.getMetrics();\n  }\n\n  /**\n   * Check if the client is ready\n   */\n  isReady(): boolean {\n    return this.isInitialized && \n           this.prover.isReady() && \n           this.verifier.isReady();\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    await Promise.all([\n      this.prover.cleanup(),\n      this.verifier.cleanup(),\n    ]);\n    this.isInitialized = false;\n  }\n\n  /**\n   * Update configuration for both prover and verifier\n   */\n  updateConfig(newConfig: Partial<ProverConfig>): void {\n    this.prover.updateConfig(newConfig);\n    // Note: Verifier doesn't have updateConfig method in current implementation\n  }\n\n  /**\n   * Ensure the client is initialized\n   */\n  private ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'ZK client not initialized. Call initialize() first.',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n  }\n} "]}