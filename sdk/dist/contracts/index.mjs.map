{"version":3,"sources":["../../src/types/index.ts","../../src/contracts/types.ts","../../src/contracts/account.ts","../../src/contracts/paymaster.ts","../../src/contracts/factory.ts","../../src/contracts/entrypoint.ts","../../src/contracts/client.ts"],"names":["z","ethers"],"mappings":"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","file":"index.mjs","sourcesContent":["import { z } from 'zod';\n\n// ============================================================================\n// ZK Proof Types\n// ============================================================================\n\n/**\n * Schema for ZK proof output from the Halo2 circuit\n */\nexport const ZkProofOutputSchema = z.object({\n  /** Length of the original input data */\n  len: z.number().int().nonnegative(),\n  /** SHA256 hash of the input as 32-byte array */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n});\n\nexport type ZkProofOutput = z.infer<typeof ZkProofOutputSchema>;\n\n/**\n * Schema for ZK proof generation result with proof bytes\n */\nexport const ZkProofResultSchema = z.object({\n  /** SHA256 hash of the input */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n  /** Serialized proof bytes */\n  proof: z.instanceof(Uint8Array),\n  /** Proof generation time in milliseconds */\n  generationTime: z.number().int().nonnegative(),\n});\n\nexport type ZkProofResult = z.infer<typeof ZkProofResultSchema>;\n\n/**\n * Configuration for ZK proof generation\n */\nexport const ZkProofConfigSchema = z.object({\n  /** Circuit size parameter (k value) */\n  circuitK: z.number().int().min(10).max(20).default(14),\n  /** Whether to use cached proving keys */\n  useCachedKeys: z.boolean().default(true),\n  /** Timeout for proof generation in milliseconds */\n  timeout: z.number().int().positive().default(30000),\n});\n\nexport type ZkProofConfig = z.infer<typeof ZkProofConfigSchema>;\n\n// ============================================================================\n// Account Abstraction Types (ERC-4337)\n// ============================================================================\n\n/**\n * Schema for UserOperation as defined in ERC-4337\n */\nexport const UserOperationSchema = z.object({\n  sender: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  nonce: z.bigint(),\n  initCode: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callGasLimit: z.bigint(),\n  verificationGasLimit: z.bigint(),\n  preVerificationGas: z.bigint(),\n  maxFeePerGas: z.bigint(),\n  maxPriorityFeePerGas: z.bigint(),\n  paymasterAndData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  signature: z.string().regex(/^0x[a-fA-F0-9]*$/),\n});\n\nexport type UserOperation = z.infer<typeof UserOperationSchema>;\n\n/**\n * Schema for account configuration\n */\nexport const AccountConfigSchema = z.object({\n  /** Account implementation address */\n  implementation: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Account factory address */\n  factory: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Entry point address */\n  entryPoint: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Initial account owner */\n  owner: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Salt for deterministic address generation */\n  salt: z.bigint().default(0n),\n});\n\nexport type AccountConfig = z.infer<typeof AccountConfigSchema>;\n\n/**\n * Schema for multi-signature account configuration\n */\nexport const MultiSigConfigSchema = z.object({\n  /** List of signer addresses */\n  signers: z.array(z.string().regex(/^0x[a-fA-F0-9]{40}$/)).min(1),\n  /** Required number of signatures (threshold) */\n  threshold: z.number().int().positive(),\n  /** Delay for signer management operations in seconds */\n  delay: z.number().int().nonnegative().default(0),\n});\n\nexport type MultiSigConfig = z.infer<typeof MultiSigConfigSchema>;\n\n/**\n * Schema for paymaster configuration\n */\nexport const PaymasterConfigSchema = z.object({\n  /** Paymaster contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Verifying signer for paymaster */\n  signer: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Valid until timestamp */\n  validUntil: z.number().int().nonnegative(),\n  /** Valid after timestamp */\n  validAfter: z.number().int().nonnegative(),\n});\n\nexport type PaymasterConfig = z.infer<typeof PaymasterConfigSchema>;\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\n/**\n * Schema for transaction data\n */\nexport const TransactionDataSchema = z.object({\n  /** Target contract address */\n  to: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Value in wei */\n  value: z.bigint().default(0n),\n  /** Call data */\n  data: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Operation type (0 = call, 1 = delegatecall) */\n  operation: z.number().int().min(0).max(1).default(0),\n});\n\nexport type TransactionData = z.infer<typeof TransactionDataSchema>;\n\n/**\n * Schema for batch transaction\n */\nexport const BatchTransactionSchema = z.object({\n  /** Array of transaction data */\n  transactions: z.array(TransactionDataSchema).min(1),\n  /** Whether to fail on first error */\n  failOnError: z.boolean().default(true),\n});\n\nexport type BatchTransaction = z.infer<typeof BatchTransactionSchema>;\n\n// ============================================================================\n// Network Types\n// ============================================================================\n\n/**\n * Schema for network configuration\n */\nexport const NetworkConfigSchema = z.object({\n  /** Chain ID */\n  chainId: z.number().int().positive(),\n  /** Network name */\n  name: z.string().min(1),\n  /** RPC URL */\n  rpcUrl: z.string().url(),\n  /** Block explorer URL */\n  explorerUrl: z.string().url().optional(),\n  /** Native currency symbol */\n  currency: z.string().min(1).default('ETH'),\n  /** Whether this is a testnet */\n  isTestnet: z.boolean().default(false),\n});\n\nexport type NetworkConfig = z.infer<typeof NetworkConfigSchema>;\n\n// ============================================================================\n// SDK Configuration Types\n// ============================================================================\n\n/**\n * Schema for SDK configuration\n */\nexport const SdkConfigSchema = z.object({\n  /** Network configuration */\n  network: NetworkConfigSchema,\n  /** ZK proof configuration */\n  zkConfig: ZkProofConfigSchema.optional(),\n  /** Account configuration */\n  accountConfig: AccountConfigSchema.optional(),\n  /** Paymaster configuration */\n  paymasterConfig: PaymasterConfigSchema.optional(),\n  /** Enable debug logging */\n  debug: z.boolean().default(false),\n});\n\nexport type SdkConfig = z.infer<typeof SdkConfigSchema>;\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/**\n * Base error class for Guardian-AA SDK\n */\nexport class GuardianAAError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'GuardianAAError';\n  }\n}\n\n/**\n * ZK proof related errors\n */\nexport class ZkProofError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'ZK_PROOF_ERROR', details);\n    this.name = 'ZkProofError';\n  }\n}\n\n/**\n * Contract interaction errors\n */\nexport class ContractError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONTRACT_ERROR', details);\n    this.name = 'ContractError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Result type for operations that can fail\n */\nexport type Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\n/**\n * Async result type\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>;\n\n/**\n * Hex string type\n */\nexport type HexString = `0x${string}`;\n\n/**\n * Address type (20-byte hex string)\n */\nexport type Address = `0x${string}`;\n\n/**\n * Bytes32 type (32-byte hex string)\n */\nexport type Bytes32 = `0x${string}`;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Default gas limits for various operations\n */\nexport const DEFAULT_GAS_LIMITS = {\n  VERIFICATION: 70000n,\n  CALL: 35000n,\n  CREATION: 1000000n,\n  PRE_VERIFICATION: 21000n,\n} as const;\n\n/**\n * Supported chain IDs\n */\nexport const SUPPORTED_CHAINS = {\n  ETHEREUM_MAINNET: 1,\n  ETHEREUM_SEPOLIA: 11155111,\n  POLYGON_MAINNET: 137,\n  POLYGON_MUMBAI: 80001,\n  ARBITRUM_ONE: 42161,\n  ARBITRUM_SEPOLIA: 421614,\n  OPTIMISM_MAINNET: 10,\n  OPTIMISM_SEPOLIA: 11155420,\n} as const;\n\n/**\n * Contract addresses for different chains\n */\nexport type ContractAddresses = {\n  entryPoint: Address;\n  accountFactory: Address;\n  multiSigFactory: Address;\n  verifyingPaymaster: Address;\n};\n\nexport const CONTRACT_ADDRESSES: Record<number, ContractAddresses> = {\n  // Ethereum Sepolia\n  [SUPPORTED_CHAINS.ETHEREUM_SEPOLIA]: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n    accountFactory: '0x9406Cc6185a346906296840746125a0E44976454',\n    multiSigFactory: '0x000000000000000000000000000000000000dEaD',\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD',\n  },\n  // Add more chains as needed\n}; ","import { z } from 'zod';\nimport type { Address } from '../types';\n\n// ============================================================================\n// Contract ABI Types\n// ============================================================================\n\n/**\n * Entry Point contract ABI (simplified)\n */\nexport const ENTRY_POINT_ABI = [\n  {\n    name: 'handleOps',\n    type: 'function',\n    inputs: [\n      { name: 'ops', type: 'tuple[]', components: [] },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getUserOpHash',\n    type: 'function',\n    inputs: [{ name: 'userOp', type: 'tuple', components: [] }],\n    outputs: [{ name: '', type: 'bytes32' }],\n  },\n] as const;\n\n/**\n * Simple Account contract ABI (simplified)\n */\nexport const SIMPLE_ACCOUNT_ABI = [\n  {\n    name: 'execute',\n    type: 'function',\n    inputs: [\n      { name: 'dest', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'func', type: 'bytes' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'executeBatch',\n    type: 'function',\n    inputs: [\n      { name: 'dest', type: 'address[]' },\n      { name: 'value', type: 'uint256[]' },\n      { name: 'func', type: 'bytes[]' },\n    ],\n    outputs: [],\n  },\n] as const;\n\n/**\n * Multi-Sig Account contract ABI (simplified)\n */\nexport const MULTI_SIG_ACCOUNT_ABI = [\n  {\n    name: 'addSigner',\n    type: 'function',\n    inputs: [{ name: 'signer', type: 'address' }],\n    outputs: [],\n  },\n  {\n    name: 'removeSigner',\n    type: 'function',\n    inputs: [{ name: 'signer', type: 'address' }],\n    outputs: [],\n  },\n  {\n    name: 'changeThreshold',\n    type: 'function',\n    inputs: [{ name: 'threshold', type: 'uint256' }],\n    outputs: [],\n  },\n] as const;\n\n/**\n * Verifying Paymaster contract ABI (simplified)\n */\nexport const VERIFYING_PAYMASTER_ABI = [\n  {\n    name: 'getHash',\n    type: 'function',\n    inputs: [\n      { name: 'userOp', type: 'tuple', components: [] },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'validAfter', type: 'uint48' },\n    ],\n    outputs: [{ name: '', type: 'bytes32' }],\n  },\n] as const;\n\n// ============================================================================\n// Contract Configuration Types\n// ============================================================================\n\n/**\n * Contract deployment configuration\n */\nexport const ContractDeployConfigSchema = z.object({\n  /** Contract bytecode */\n  bytecode: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Constructor arguments */\n  constructorArgs: z.array(z.unknown()).default([]),\n  /** Gas limit for deployment */\n  gasLimit: z.bigint().optional(),\n  /** Gas price */\n  gasPrice: z.bigint().optional(),\n  /** Salt for CREATE2 deployment */\n  salt: z.string().regex(/^0x[a-fA-F0-9]{64}$/).optional(),\n});\n\nexport type ContractDeployConfig = z.infer<typeof ContractDeployConfigSchema>;\n\n/**\n * Contract interaction configuration\n */\nexport const ContractCallConfigSchema = z.object({\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Function name */\n  functionName: z.string().min(1),\n  /** Function arguments */\n  args: z.array(z.unknown()).default([]),\n  /** Value to send with the call */\n  value: z.bigint().default(0n),\n  /** Gas limit */\n  gasLimit: z.bigint().optional(),\n});\n\nexport type ContractCallConfig = z.infer<typeof ContractCallConfigSchema>;\n\n// ============================================================================\n// Account Operation Types\n// ============================================================================\n\n/**\n * Account operation result\n */\nexport const AccountOperationResultSchema = z.object({\n  /** Transaction hash */\n  txHash: z.string().regex(/^0x[a-fA-F0-9]{64}$/),\n  /** Block number */\n  blockNumber: z.number().int().nonnegative(),\n  /** Gas used */\n  gasUsed: z.bigint(),\n  /** Operation status */\n  status: z.enum(['SUCCESS', 'FAILED', 'PENDING']),\n  /** Error message if failed */\n  error: z.string().optional(),\n});\n\nexport type AccountOperationResult = z.infer<typeof AccountOperationResultSchema>;\n\n/**\n * Signature data for multi-sig operations\n */\nexport const SignatureDataSchema = z.object({\n  /** Signer address */\n  signer: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Signature bytes */\n  signature: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Signature type (ECDSA, etc.) */\n  signatureType: z.enum(['ECDSA', 'EIP1271']).default('ECDSA'),\n});\n\nexport type SignatureData = z.infer<typeof SignatureDataSchema>;\n\n// ============================================================================\n// Gas Estimation Types\n// ============================================================================\n\n/**\n * Gas estimation result\n */\nexport const GasEstimationSchema = z.object({\n  /** Estimated gas limit */\n  gasLimit: z.bigint(),\n  /** Estimated gas price */\n  gasPrice: z.bigint(),\n  /** Maximum fee per gas (EIP-1559) */\n  maxFeePerGas: z.bigint().optional(),\n  /** Maximum priority fee per gas (EIP-1559) */\n  maxPriorityFeePerGas: z.bigint().optional(),\n  /** Estimated total cost in wei */\n  totalCost: z.bigint(),\n});\n\nexport type GasEstimation = z.infer<typeof GasEstimationSchema>;\n\n// ============================================================================\n// Event Types\n// ============================================================================\n\n/**\n * Contract event filter\n */\nexport const EventFilterSchema = z.object({\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Event topics */\n  topics: z.array(z.string().regex(/^0x[a-fA-F0-9]{64}$/)).optional(),\n  /** From block */\n  fromBlock: z.union([z.number().int().nonnegative(), z.literal('latest')]).default('latest'),\n  /** To block */\n  toBlock: z.union([z.number().int().nonnegative(), z.literal('latest')]).default('latest'),\n});\n\nexport type EventFilter = z.infer<typeof EventFilterSchema>;\n\n/**\n * Contract event log\n */\nexport const ContractEventSchema = z.object({\n  /** Event name */\n  eventName: z.string(),\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Block number */\n  blockNumber: z.number().int().nonnegative(),\n  /** Transaction hash */\n  transactionHash: z.string().regex(/^0x[a-fA-F0-9]{64}$/),\n  /** Event data */\n  data: z.record(z.unknown()),\n});\n\nexport type ContractEvent = z.infer<typeof ContractEventSchema>;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Default contract addresses for supported networks\n */\nexport const DEFAULT_CONTRACT_ADDRESSES: Record<number, {\n  entryPoint: Address;\n  simpleAccountFactory: Address;\n  multiSigAccountFactory: Address;\n  verifyingPaymaster: Address;\n}> = {\n  // Local testnet (Hardhat/Anvil)\n  31337: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as Address,\n    simpleAccountFactory: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0' as Address,\n    multiSigAccountFactory: '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9' as Address,\n    verifyingPaymaster: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9' as Address,\n  },\n  // Ethereum Sepolia\n  11155111: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as Address,\n    simpleAccountFactory: '0x9406Cc6185a346906296840746125a0E44976454' as Address,\n    multiSigAccountFactory: '0x000000000000000000000000000000000000dEaD' as Address,\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD' as Address,\n  },\n} as const;\n\n/**\n * Contract deployment gas limits\n */\nexport const CONTRACT_GAS_LIMITS = {\n  SIMPLE_ACCOUNT_DEPLOY: 1000000n,\n  MULTI_SIG_ACCOUNT_DEPLOY: 1500000n,\n  PAYMASTER_DEPLOY: 800000n,\n  ENTRY_POINT_DEPLOY: 2000000n,\n} as const;\n\n/**\n * Function selectors for common operations\n */\nexport const FUNCTION_SELECTORS = {\n  EXECUTE: '0xb61d27f6',\n  EXECUTE_BATCH: '0x18dfb3c7',\n  ADD_SIGNER: '0x7065cb48',\n  REMOVE_SIGNER: '0x0e316ab7',\n  CHANGE_THRESHOLD: '0x694e80c3',\n} as const; ","import { ethers } from 'ethers';\nimport { ContractError, ValidationError } from '../types';\nimport type { \n  UserOperation, \n  TransactionData, \n  BatchTransaction,\n  Address,\n  HexString,\n} from '../types';\nimport {\n  AccountOperationResult,\n  SignatureData,\n  GasEstimation,\n  SIMPLE_ACCOUNT_ABI,\n  MULTI_SIG_ACCOUNT_ABI,\n  CONTRACT_GAS_LIMITS,\n} from './types';\n\n/**\n * Base class for account abstraction wallets\n */\nexport abstract class BaseAccount {\n  protected provider: ethers.Provider;\n  protected address: Address;\n  protected entryPointAddress: Address;\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address\n  ) {\n    this.provider = provider;\n    this.address = address;\n    this.entryPointAddress = entryPointAddress;\n  }\n\n  /**\n   * Get the account address\n   */\n  getAddress(): Address {\n    return this.address;\n  }\n\n  /**\n   * Get the current nonce for the account\n   */\n  async getNonce(): Promise<bigint> {\n    try {\n      const contract = new ethers.Contract(\n        this.address,\n        ['function getNonce() view returns (uint256)'],\n        this.provider\n      );\n      \n      const getNonceMethod = contract['getNonce'];\n      if (!getNonceMethod) {\n        throw new Error('getNonce method not found on contract');\n      }\n      \n      const result = await getNonceMethod();\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get account nonce',\n        { error, address: this.address }\n      );\n    }\n  }\n\n  /**\n   * Estimate gas for a transaction\n   */\n  async estimateGas(transaction: TransactionData): Promise<GasEstimation> {\n    try {\n      const feeData = await this.provider.getFeeData();\n      const gasLimit = await this.provider.estimateGas({\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data,\n      });\n\n      const gasPrice = feeData.gasPrice ?? 0n;\n      const maxFeePerGas = feeData.maxFeePerGas ?? gasPrice;\n      const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? 0n;\n\n      return {\n        gasLimit: gasLimit + (gasLimit / 10n), // Add 10% buffer\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        totalCost: gasLimit * gasPrice,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to estimate gas',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Build a UserOperation for the given transaction\n   */\n  abstract buildUserOperation(\n    transaction: TransactionData,\n    options?: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    }\n  ): Promise<UserOperation>;\n\n  /**\n   * Execute a single transaction\n   */\n  abstract execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult>;\n\n  /**\n   * Execute multiple transactions in batch\n   */\n  abstract executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult>;\n}\n\n/**\n * Simple Account implementation (ECDSA signature-based)\n */\nexport class SimpleAccount extends BaseAccount {\n  private contract: ethers.Contract;\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address\n  ) {\n    super(provider, address, entryPointAddress);\n    this.contract = new ethers.Contract(address, SIMPLE_ACCOUNT_ABI, provider);\n  }\n\n  /**\n   * Build a UserOperation for a simple account transaction\n   */\n  async buildUserOperation(\n    transaction: TransactionData,\n    options: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    } = {}\n  ): Promise<UserOperation> {\n    try {\n      const nonce = options.nonce ?? await this.getNonce();\n      const gasEstimation = await this.estimateGas(transaction);\n\n      // Encode the execute function call\n      const callData = this.contract.interface.encodeFunctionData('execute', [\n        transaction.to,\n        transaction.value,\n        transaction.data,\n      ]);\n\n      return {\n        sender: this.address,\n        nonce,\n        initCode: '0x', // Account already deployed\n        callData,\n        callGasLimit: options.gasLimits?.gasLimit ?? gasEstimation.gasLimit,\n        verificationGasLimit: CONTRACT_GAS_LIMITS.SIMPLE_ACCOUNT_DEPLOY / 10n,\n        preVerificationGas: 21000n,\n        maxFeePerGas: options.gasLimits?.maxFeePerGas ?? gasEstimation.maxFeePerGas ?? 0n,\n        maxPriorityFeePerGas: options.gasLimits?.maxPriorityFeePerGas ?? gasEstimation.maxPriorityFeePerGas ?? 0n,\n        paymasterAndData: options.paymasterData ?? '0x',\n        signature: '0x', // Will be filled by the signer\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to build UserOperation',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute a single transaction\n   */\n  async execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const userOp = await this.buildUserOperation(transaction);\n      userOp.signature = signature;\n\n      // In a real implementation, this would submit to a bundler\n      // For now, we'll simulate the execution\n      const txHash = ethers.keccak256(\n        ethers.toUtf8Bytes(JSON.stringify(userOp))\n      );\n\n      return {\n        txHash: txHash as HexString,\n        blockNumber: await this.provider.getBlockNumber(),\n        gasUsed: userOp.callGasLimit,\n        status: 'SUCCESS',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute multiple transactions in batch\n   */\n  async executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const destinations = batch.transactions.map(tx => tx.to);\n      const values = batch.transactions.map(tx => tx.value);\n      const datas = batch.transactions.map(tx => tx.data);\n\n      // Encode the executeBatch function call\n      const callData = this.contract.interface.encodeFunctionData('executeBatch', [\n        destinations,\n        values,\n        datas,\n      ]);\n\n      const batchTransaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      return this.execute(batchTransaction, signature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute batch transaction',\n        { error, batch }\n      );\n    }\n  }\n}\n\n/**\n * Multi-Signature Account implementation\n */\nexport class MultiSigAccount extends BaseAccount {\n  private contract: ethers.Contract;\n  private threshold: number;\n  private signers: Address[];\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ) {\n    super(provider, address, entryPointAddress);\n    this.contract = new ethers.Contract(address, MULTI_SIG_ACCOUNT_ABI, provider);\n    this.threshold = threshold;\n    this.signers = signers;\n  }\n\n  /**\n   * Get current signers and threshold\n   */\n  async getSignerInfo(): Promise<{ signers: Address[]; threshold: number }> {\n    try {\n      // In a real implementation, this would query the contract\n      return {\n        signers: this.signers,\n        threshold: this.threshold,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get signer info',\n        { error, address: this.address }\n      );\n    }\n  }\n\n  /**\n   * Add a new signer to the multi-sig account\n   */\n  async addSigner(\n    newSigner: Address,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('addSigner', [\n        newSigner,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      // Combine signatures for multi-sig verification\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      return this.execute(transaction, combinedSignature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to add signer',\n        { error, newSigner, signatures }\n      );\n    }\n  }\n\n  /**\n   * Remove a signer from the multi-sig account\n   */\n  async removeSigner(\n    signerToRemove: Address,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('removeSigner', [\n        signerToRemove,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      return this.execute(transaction, combinedSignature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to remove signer',\n        { error, signerToRemove, signatures }\n      );\n    }\n  }\n\n  /**\n   * Change the signature threshold\n   */\n  async changeThreshold(\n    newThreshold: number,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    if (newThreshold > this.signers.length) {\n      throw new ValidationError(\n        `Threshold ${newThreshold} cannot exceed number of signers ${this.signers.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('changeThreshold', [\n        newThreshold,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      const result = await this.execute(transaction, combinedSignature);\n      \n      // Update local threshold after successful execution\n      this.threshold = newThreshold;\n      \n      return result;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to change threshold',\n        { error, newThreshold, signatures }\n      );\n    }\n  }\n\n  /**\n   * Build UserOperation for multi-sig account\n   */\n  async buildUserOperation(\n    transaction: TransactionData,\n    options: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    } = {}\n  ): Promise<UserOperation> {\n    try {\n      const nonce = options.nonce ?? await this.getNonce();\n      const gasEstimation = await this.estimateGas(transaction);\n\n      // Encode the execute function call\n      const callData = this.contract.interface.encodeFunctionData('execute', [\n        transaction.to,\n        transaction.value,\n        transaction.data,\n      ]);\n\n      return {\n        sender: this.address,\n        nonce,\n        initCode: '0x', // Account already deployed\n        callData,\n        callGasLimit: options.gasLimits?.gasLimit ?? gasEstimation.gasLimit,\n        verificationGasLimit: CONTRACT_GAS_LIMITS.MULTI_SIG_ACCOUNT_DEPLOY / 5n,\n        preVerificationGas: 21000n,\n        maxFeePerGas: options.gasLimits?.maxFeePerGas ?? gasEstimation.maxFeePerGas ?? 0n,\n        maxPriorityFeePerGas: options.gasLimits?.maxPriorityFeePerGas ?? gasEstimation.maxPriorityFeePerGas ?? 0n,\n        paymasterAndData: options.paymasterData ?? '0x',\n        signature: '0x', // Will be filled by the signer\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to build UserOperation for multi-sig account',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute with multi-sig verification\n   */\n  async execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const userOp = await this.buildUserOperation(transaction);\n      userOp.signature = signature;\n\n      // In a real implementation, this would submit to a bundler\n      // For now, we'll simulate the execution\n      const txHash = ethers.keccak256(\n        ethers.toUtf8Bytes(JSON.stringify(userOp))\n      );\n\n      return {\n        txHash: txHash as HexString,\n        blockNumber: await this.provider.getBlockNumber(),\n        gasUsed: userOp.callGasLimit,\n        status: 'SUCCESS',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute multi-sig transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute batch with multi-sig verification\n   */\n  async executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const destinations = batch.transactions.map(tx => tx.to);\n      const values = batch.transactions.map(tx => tx.value);\n      const datas = batch.transactions.map(tx => tx.data);\n\n      // Encode the executeBatch function call\n      const callData = this.contract.interface.encodeFunctionData('executeBatch', [\n        destinations,\n        values,\n        datas,\n      ]);\n\n      const batchTransaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      return this.execute(batchTransaction, signature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute multi-sig batch transaction',\n        { error, batch }\n      );\n    }\n  }\n\n  /**\n   * Combine multiple signatures into a single signature for multi-sig verification\n   */\n  private combineSignatures(signatures: SignatureData[]): HexString {\n    // Sort signatures by signer address to ensure deterministic order\n    const sortedSignatures = signatures.sort((a, b) => \n      a.signer.toLowerCase().localeCompare(b.signer.toLowerCase())\n    );\n\n    // Combine signatures (implementation depends on the multi-sig contract format)\n    const combined = sortedSignatures\n      .map(sig => sig.signature.slice(2)) // Remove 0x prefix\n      .join('');\n\n    return `0x${combined}` as HexString;\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { UserOperation, Address, HexString } from '../types';\nimport { VERIFYING_PAYMASTER_ABI } from './types';\n\n/**\n * Paymaster configuration for gasless transactions\n */\nexport interface ContractPaymasterConfig {\n  address: Address;\n  signer: ethers.Wallet;\n  validUntil: number;\n  validAfter: number;\n}\n\n/**\n * Paymaster signature data\n */\nexport interface PaymasterSignature {\n  validUntil: number;\n  validAfter: number;\n  signature: HexString;\n}\n\n/**\n * Verifying Paymaster implementation for sponsoring user operations\n */\nexport class VerifyingPaymaster {\n  private provider: ethers.Provider;\n  private config: ContractPaymasterConfig;\n\n  constructor(provider: ethers.Provider, config: ContractPaymasterConfig) {\n    this.provider = provider;\n    this.config = config;\n  }\n\n  /**\n   * Generate paymaster data for a user operation\n   */\n  async generatePaymasterData(\n    userOp: UserOperation,\n    validUntil?: number,\n    validAfter?: number\n  ): Promise<HexString> {\n    try {\n      const until = validUntil ?? this.config.validUntil;\n      const after = validAfter ?? this.config.validAfter;\n\n      // Get the hash that needs to be signed\n      const hash = await this.getPaymasterHash(userOp, until, after);\n      \n      // Sign the hash\n      const signature = await this.config.signer.signMessage(\n        ethers.getBytes(hash)\n      );\n\n      // Encode paymaster data: address + validUntil + validAfter + signature\n      const paymasterData = ethers.solidityPacked(\n        ['address', 'uint48', 'uint48', 'bytes'],\n        [this.config.address, until, after, signature]\n      );\n\n      return paymasterData as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to generate paymaster data',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Verify if a user operation can be sponsored\n   */\n  async canSponsor(userOp: UserOperation): Promise<boolean> {\n    try {\n      // Check if the paymaster has sufficient balance\n      const balance = await this.getBalance();\n      const estimatedCost = this.estimateOperationCost(userOp);\n\n      if (balance < estimatedCost) {\n        return false;\n      }\n\n      // Additional sponsorship logic can be added here\n      // e.g., whitelist checks, rate limiting, etc.\n      \n      return true;\n    } catch (error) {\n      // If we can't determine sponsorship eligibility, err on the side of caution\n      return false;\n    }\n  }\n\n  /**\n   * Get the paymaster's balance in the EntryPoint\n   */\n  async getBalance(): Promise<bigint> {\n    try {\n      // In a real implementation, this would query the EntryPoint contract\n      // for the paymaster's deposited balance\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789', // Standard EntryPoint address\n        ['function balanceOf(address) view returns (uint256)'],\n        this.provider\n      );\n\n      const balanceOfMethod = entryPointContract['balanceOf'];\n      if (!balanceOfMethod) {\n        throw new Error('balanceOf method not found on contract');\n      }\n      return await balanceOfMethod(this.config.address) as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get paymaster balance',\n        { error, address: this.config.address }\n      );\n    }\n  }\n\n  /**\n   * Deposit funds to the paymaster's EntryPoint balance\n   */\n  async deposit(amount: bigint): Promise<string> {\n    try {\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n        ['function depositTo(address) payable'],\n        this.config.signer\n      );\n\n      const depositToMethod = entryPointContract['depositTo'];\n      if (!depositToMethod) {\n        throw new Error('depositTo method not found on contract');\n      }\n      const tx = await depositToMethod(this.config.address, {\n        value: amount,\n      });\n\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deposit to paymaster',\n        { error, amount }\n      );\n    }\n  }\n\n  /**\n   * Withdraw funds from the paymaster's EntryPoint balance\n   */\n  async withdraw(amount: bigint, to: Address): Promise<string> {\n    try {\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n        ['function withdrawTo(address, uint256)'],\n        this.config.signer\n      );\n\n      const withdrawToMethod = entryPointContract['withdrawTo'];\n      if (!withdrawToMethod) {\n        throw new Error('withdrawTo method not found on contract');\n      }\n      const tx = await withdrawToMethod(to, amount);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to withdraw from paymaster',\n        { error, amount, to }\n      );\n    }\n  }\n\n  /**\n   * Update paymaster configuration\n   */\n  updateConfig(newConfig: Partial<ContractPaymasterConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get the current paymaster configuration\n   */\n  getConfig(): ContractPaymasterConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get the hash that needs to be signed for paymaster verification\n   */\n  private async getPaymasterHash(\n    userOp: UserOperation,\n    validUntil: number,\n    validAfter: number\n  ): Promise<string> {\n    try {\n      // In a real implementation, this would call the paymaster contract\n      // For now, we'll create a hash manually\n      const encoded = ethers.solidityPacked(\n        ['address', 'uint256', 'bytes32', 'uint48', 'uint48'],\n        [\n          userOp.sender,\n          userOp.nonce,\n          ethers.keccak256(userOp.callData),\n          validUntil,\n          validAfter,\n        ]\n      );\n\n      return ethers.keccak256(encoded);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get paymaster hash',\n        { error, userOp, validUntil, validAfter }\n      );\n    }\n  }\n\n  /**\n   * Estimate the cost of sponsoring a user operation\n   */\n  private estimateOperationCost(userOp: UserOperation): bigint {\n    // Estimate total gas cost including verification and execution\n    const totalGas = userOp.callGasLimit + \n                    userOp.verificationGasLimit + \n                    userOp.preVerificationGas;\n    \n    const gasPrice = userOp.maxFeePerGas;\n    \n    return totalGas * gasPrice;\n  }\n}\n\n/**\n * Factory for creating paymaster instances\n */\nexport class PaymasterFactory {\n  private provider: ethers.Provider;\n\n  constructor(provider: ethers.Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Create a new VerifyingPaymaster instance\n   */\n  createVerifyingPaymaster(config: ContractPaymasterConfig): VerifyingPaymaster {\n    return new VerifyingPaymaster(this.provider, config);\n  }\n\n  /**\n   * Deploy a new paymaster contract\n   */\n  async deployPaymaster(\n    deployer: ethers.Wallet,\n    entryPointAddress: Address,\n    owner: Address\n  ): Promise<{ address: Address; txHash: string }> {\n    try {\n      // In a real implementation, this would deploy the actual paymaster contract\n      // For now, we'll simulate the deployment\n      const factory = new ethers.ContractFactory(\n        VERIFYING_PAYMASTER_ABI,\n        '0x', // Bytecode would be here\n        deployer\n      );\n\n      const contract = await factory.deploy(entryPointAddress, owner);\n      await contract.waitForDeployment();\n\n      return {\n        address: await contract.getAddress() as Address,\n        txHash: contract.deploymentTransaction()?.hash ?? '',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy paymaster',\n        { error, entryPointAddress, owner }\n      );\n    }\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { Address, HexString } from '../types';\nimport { SimpleAccount, MultiSigAccount } from './account';\n\n/**\n * Account factory configuration\n */\nexport interface AccountFactoryConfig {\n  factoryAddress: Address;\n  entryPointAddress: Address;\n  implementationAddress: Address;\n}\n\n/**\n * Account deployment result\n */\nexport interface AccountDeploymentResult {\n  accountAddress: Address;\n  txHash: string;\n  isNewDeployment: boolean;\n}\n\n/**\n * Simple Account Factory implementation\n */\nexport class SimpleAccountFactory {\n  private provider: ethers.Provider;\n  private config: AccountFactoryConfig;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, config: AccountFactoryConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.contract = new ethers.Contract(\n      config.factoryAddress,\n      [\n        'function createAccount(address owner, uint256 salt) returns (address)',\n        'function getAddress(address owner, uint256 salt) view returns (address)',\n      ],\n      provider\n    );\n  }\n\n  /**\n   * Calculate the counterfactual address for a simple account\n   */\n  async getAccountAddress(owner: Address, salt: bigint): Promise<Address> {\n    try {\n      const result = await this.contract.getFunction('getAddress')(owner, salt);\n      return result as Address;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get account address',\n        { error, owner, salt }\n      );\n    }\n  }\n\n  /**\n   * Deploy a new simple account\n   */\n  async deployAccount(\n    owner: Address,\n    salt: bigint,\n    signer?: ethers.Wallet\n  ): Promise<AccountDeploymentResult> {\n    try {\n      // First check if account already exists\n      const accountAddress = await this.getAccountAddress(owner, salt);\n      const code = await this.provider.getCode(accountAddress);\n      \n      if (code !== '0x') {\n        // Account already deployed\n        return {\n          accountAddress,\n          txHash: '',\n          isNewDeployment: false,\n        };\n      }\n\n      // Deploy new account\n      if (!signer) {\n        throw new ContractError('Signer required for deployment');\n      }\n\n      const factoryWithSigner = this.contract.connect(signer);\n      const tx = await factoryWithSigner.getFunction('createAccount')(owner, salt);\n      await tx.wait();\n\n      return {\n        accountAddress,\n        txHash: tx.hash,\n        isNewDeployment: true,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy account',\n        { error, owner, salt }\n      );\n    }\n  }\n\n  /**\n   * Create a SimpleAccount instance\n   */\n  createAccountInstance(accountAddress: Address): SimpleAccount {\n    return new SimpleAccount(\n      this.provider,\n      accountAddress,\n      this.config.entryPointAddress\n    );\n  }\n\n  /**\n   * Get the init code for account deployment\n   */\n  async getInitCode(owner: Address, salt: bigint): Promise<HexString> {\n    try {\n      const initCallData = this.contract.interface.encodeFunctionData(\n        'createAccount',\n        [owner, salt]\n      );\n\n      return `${this.config.factoryAddress}${initCallData.slice(2)}` as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get init code',\n        { error, owner, salt }\n      );\n    }\n  }\n}\n\n/**\n * Multi-Sig Account Factory implementation\n */\nexport class MultiSigAccountFactory {\n  private provider: ethers.Provider;\n  private config: AccountFactoryConfig;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, config: AccountFactoryConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.contract = new ethers.Contract(\n      config.factoryAddress,\n      [\n        'function createAccount(address[] owners, uint256 threshold, uint256 salt) returns (address)',\n        'function getAddress(address[] owners, uint256 threshold, uint256 salt) view returns (address)',\n      ],\n      provider\n    );\n  }\n\n  /**\n   * Calculate the counterfactual address for a multi-sig account\n   */\n  async getAccountAddress(\n    owners: Address[],\n    threshold: number,\n    salt: bigint\n  ): Promise<Address> {\n    try {\n      const result = await this.contract.getFunction('getAddress')(owners, threshold, salt);\n      return result as Address;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get multi-sig account address',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n\n  /**\n   * Deploy a new multi-sig account\n   */\n  async deployAccount(\n    owners: Address[],\n    threshold: number,\n    salt: bigint,\n    signer?: ethers.Wallet\n  ): Promise<AccountDeploymentResult> {\n    try {\n      // Validate inputs\n      if (owners.length === 0) {\n        throw new ContractError('At least one owner required');\n      }\n      if (threshold > owners.length) {\n        throw new ContractError('Threshold cannot exceed number of owners');\n      }\n      if (threshold === 0) {\n        throw new ContractError('Threshold must be greater than 0');\n      }\n\n      // Check if account already exists\n      const accountAddress = await this.getAccountAddress(owners, threshold, salt);\n      const code = await this.provider.getCode(accountAddress);\n      \n      if (code !== '0x') {\n        return {\n          accountAddress,\n          txHash: '',\n          isNewDeployment: false,\n        };\n      }\n\n      // Deploy new account\n      if (!signer) {\n        throw new ContractError('Signer required for deployment');\n      }\n\n      const factoryWithSigner = this.contract.connect(signer);\n      const tx = await factoryWithSigner.getFunction('createAccount')(owners, threshold, salt);\n      await tx.wait();\n\n      return {\n        accountAddress,\n        txHash: tx.hash,\n        isNewDeployment: true,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy multi-sig account',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n\n  /**\n   * Create a MultiSigAccount instance\n   */\n  createAccountInstance(\n    accountAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ): MultiSigAccount {\n    return new MultiSigAccount(\n      this.provider,\n      accountAddress,\n      this.config.entryPointAddress,\n      threshold,\n      signers\n    );\n  }\n\n  /**\n   * Get the init code for multi-sig account deployment\n   */\n  async getInitCode(\n    owners: Address[],\n    threshold: number,\n    salt: bigint\n  ): Promise<HexString> {\n    try {\n      const initCallData = this.contract.interface.encodeFunctionData(\n        'createAccount',\n        [owners, threshold, salt]\n      );\n\n      return `${this.config.factoryAddress}${initCallData.slice(2)}` as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get multi-sig init code',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n}\n\n/**\n * Factory manager for creating different types of account factories\n */\nexport class AccountFactoryManager {\n  private provider: ethers.Provider;\n\n  constructor(provider: ethers.Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Create a SimpleAccountFactory instance\n   */\n  createSimpleAccountFactory(config: AccountFactoryConfig): SimpleAccountFactory {\n    return new SimpleAccountFactory(this.provider, config);\n  }\n\n  /**\n   * Create a MultiSigAccountFactory instance\n   */\n  createMultiSigAccountFactory(config: AccountFactoryConfig): MultiSigAccountFactory {\n    return new MultiSigAccountFactory(this.provider, config);\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { UserOperation, Address, HexString } from '../types';\nimport { ENTRY_POINT_ABI } from './types';\n\n/**\n * EntryPoint client for ERC-4337 operations\n */\nexport class EntryPointClient {\n  private provider: ethers.Provider;\n  private address: Address;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, address: Address) {\n    this.provider = provider;\n    this.address = address;\n    this.contract = new ethers.Contract(address, ENTRY_POINT_ABI, provider);\n  }\n\n  /**\n   * Get the EntryPoint contract address\n   */\n  getAddress(): Address {\n    return this.address;\n  }\n\n  /**\n   * Calculate the hash of a UserOperation\n   */\n  async getUserOpHash(userOp: UserOperation): Promise<HexString> {\n    try {\n      const result = await this.contract.getFunction('getUserOpHash')(userOp);\n      return result as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get UserOperation hash',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Handle a batch of UserOperations (submit to bundler)\n   */\n  async handleOps(\n    userOps: UserOperation[],\n    beneficiary: Address,\n    signer: ethers.Wallet\n  ): Promise<string> {\n    try {\n      const contractWithSigner = this.contract.connect(signer);\n      const tx = await contractWithSigner.getFunction('handleOps')(userOps, beneficiary);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to handle UserOperations',\n        { error, userOps, beneficiary }\n      );\n    }\n  }\n\n  /**\n   * Simulate a UserOperation to check for validation errors\n   */\n  async simulateValidation(userOp: UserOperation): Promise<{\n    preOpGas: bigint;\n    prefund: bigint;\n    sigFailed: boolean;\n    validAfter: number;\n    validUntil: number;\n  }> {\n    try {\n      // In a real implementation, this would call simulateValidation\n      // For now, we'll return mock data\n      return {\n        preOpGas: 50000n,\n        prefund: userOp.callGasLimit * userOp.maxFeePerGas,\n        sigFailed: false,\n        validAfter: 0,\n        validUntil: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to simulate validation',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Get the deposit balance for an account\n   */\n  async balanceOf(account: Address): Promise<bigint> {\n    try {\n      const balanceContract = new ethers.Contract(\n        this.address,\n        ['function balanceOf(address) view returns (uint256)'],\n        this.provider\n      );\n      const result = await balanceContract.getFunction('balanceOf')(account);\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get balance',\n        { error, account }\n      );\n    }\n  }\n\n  /**\n   * Deposit ETH for an account\n   */\n  async depositTo(account: Address, amount: bigint, signer: ethers.Wallet): Promise<string> {\n    try {\n      const depositContract = new ethers.Contract(\n        this.address,\n        ['function depositTo(address) payable'],\n        signer\n      );\n      const tx = await depositContract.getFunction('depositTo')(account, { value: amount });\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deposit',\n        { error, account, amount }\n      );\n    }\n  }\n\n  /**\n   * Withdraw ETH from an account's deposit\n   */\n  async withdrawTo(\n    withdrawAddress: Address,\n    amount: bigint,\n    signer: ethers.Wallet\n  ): Promise<string> {\n    try {\n      const withdrawContract = new ethers.Contract(\n        this.address,\n        ['function withdrawTo(address, uint256)'],\n        signer\n      );\n      const tx = await withdrawContract.getFunction('withdrawTo')(withdrawAddress, amount);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to withdraw',\n        { error, withdrawAddress, amount }\n      );\n    }\n  }\n\n  /**\n   * Get the nonce for an account\n   */\n  async getNonce(account: Address, key: bigint = 0n): Promise<bigint> {\n    try {\n      const nonceContract = new ethers.Contract(\n        this.address,\n        ['function getNonce(address, uint192) view returns (uint256)'],\n        this.provider\n      );\n      const result = await nonceContract.getFunction('getNonce')(account, key);\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get nonce',\n        { error, account, key }\n      );\n    }\n  }\n\n  /**\n   * Check if an operation is valid\n   */\n  async validateUserOp(userOp: UserOperation): Promise<boolean> {\n    try {\n      // Perform basic validation checks\n      if (!userOp.sender || !ethers.isAddress(userOp.sender)) {\n        return false;\n      }\n\n      if (userOp.nonce < 0n) {\n        return false;\n      }\n\n      if (userOp.callGasLimit < 0n || userOp.verificationGasLimit < 0n) {\n        return false;\n      }\n\n      // Additional validation logic can be added here\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Estimate gas for a UserOperation\n   */\n  async estimateUserOpGas(userOp: UserOperation): Promise<{\n    callGasLimit: bigint;\n    verificationGasLimit: bigint;\n    preVerificationGas: bigint;\n  }> {\n    try {\n      // In a real implementation, this would call the EntryPoint's estimation methods\n      // For now, we'll provide reasonable estimates\n      const baseGas = 21000n;\n      const callDataGas = BigInt(userOp.callData.length - 2) * 16n / 2n; // Rough estimate\n      \n      return {\n        callGasLimit: baseGas + callDataGas + 50000n,\n        verificationGasLimit: 100000n,\n        preVerificationGas: 21000n,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to estimate gas',\n        { error, userOp }\n      );\n    }\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError, ConfigError } from '../types';\nimport type { \n  UserOperation, \n  TransactionData, \n  BatchTransaction,\n  Address, \n  HexString,\n  NetworkConfig,\n} from '../types';\nimport { SimpleAccount, MultiSigAccount } from './account';\nimport { VerifyingPaymaster, PaymasterFactory } from './paymaster';\nimport { SimpleAccountFactory, MultiSigAccountFactory, AccountFactoryManager } from './factory';\nimport { EntryPointClient } from './entrypoint';\nimport { DEFAULT_CONTRACT_ADDRESSES } from './types';\n\n/**\n * Configuration for the contracts client\n */\nexport interface ContractsClientConfig {\n  network: NetworkConfig;\n  entryPointAddress?: Address;\n  simpleAccountFactoryAddress?: Address;\n  multiSigAccountFactoryAddress?: Address;\n  verifyingPaymasterAddress?: Address;\n  signer?: ethers.Wallet;\n}\n\n/**\n * Main contracts client that provides a unified interface for all contract operations\n */\nexport class ContractsClient {\n  private provider: ethers.Provider;\n  private config: ContractsClientConfig;\n  private entryPoint: EntryPointClient;\n  private accountFactoryManager: AccountFactoryManager;\n  private paymasterFactory: PaymasterFactory;\n  private signer?: ethers.Wallet;\n\n  constructor(config: ContractsClientConfig) {\n    this.config = config;\n    this.provider = new ethers.JsonRpcProvider(config.network.rpcUrl);\n    \n    if (config.signer) {\n      this.signer = config.signer.connect(this.provider);\n    }\n\n    // Initialize EntryPoint\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    this.entryPoint = new EntryPointClient(this.provider, entryPointAddress);\n\n    // Initialize factories\n    this.accountFactoryManager = new AccountFactoryManager(this.provider);\n    this.paymasterFactory = new PaymasterFactory(this.provider);\n  }\n\n  /**\n   * Get contract address for the current network\n   */\n  private getContractAddress(contractType: string): Address {\n    const chainId = this.config.network.chainId;\n    const addresses = DEFAULT_CONTRACT_ADDRESSES[chainId];\n    \n    if (!addresses) {\n      throw new ConfigError(\n        `No contract addresses configured for chain ID ${chainId}`\n      );\n    }\n\n    // Check for custom addresses in config first\n    switch (contractType) {\n      case 'entryPoint':\n        return this.config.entryPointAddress ?? addresses.entryPoint;\n      case 'simpleAccountFactory':\n        return this.config.simpleAccountFactoryAddress ?? addresses.simpleAccountFactory;\n      case 'multiSigAccountFactory':\n        return this.config.multiSigAccountFactoryAddress ?? addresses.multiSigAccountFactory;\n      case 'verifyingPaymaster':\n        return this.config.verifyingPaymasterAddress ?? addresses.verifyingPaymaster;\n      default:\n        throw new ConfigError(`Unknown contract type: ${contractType}`);\n    }\n  }\n\n  /**\n   * Create a simple account factory\n   */\n  createSimpleAccountFactory(): SimpleAccountFactory {\n    const factoryAddress = this.getContractAddress('simpleAccountFactory');\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    \n    return this.accountFactoryManager.createSimpleAccountFactory({\n      factoryAddress,\n      entryPointAddress,\n      implementationAddress: factoryAddress, // Simplified for demo\n    });\n  }\n\n  /**\n   * Create a multi-sig account factory\n   */\n  createMultiSigAccountFactory(): MultiSigAccountFactory {\n    const factoryAddress = this.getContractAddress('multiSigAccountFactory');\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    \n    return this.accountFactoryManager.createMultiSigAccountFactory({\n      factoryAddress,\n      entryPointAddress,\n      implementationAddress: factoryAddress, // Simplified for demo\n    });\n  }\n\n  /**\n   * Create a verifying paymaster\n   */\n  createVerifyingPaymaster(signer: ethers.Wallet): VerifyingPaymaster {\n    if (!signer) {\n      throw new ConfigError('Signer required for paymaster operations');\n    }\n\n    const paymasterAddress = this.getContractAddress('verifyingPaymaster');\n    \n    return this.paymasterFactory.createVerifyingPaymaster({\n      address: paymasterAddress,\n      signer: signer.connect(this.provider),\n      validUntil: Math.floor(Date.now() / 1000) + 3600, // 1 hour\n      validAfter: Math.floor(Date.now() / 1000) - 60, // 1 minute ago\n    });\n  }\n\n  /**\n   * Deploy a new simple account\n   */\n  async deploySimpleAccount(\n    owner: Address,\n    salt: bigint = 0n\n  ): Promise<SimpleAccount> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for account deployment');\n    }\n\n    const factory = this.createSimpleAccountFactory();\n    const result = await factory.deployAccount(owner, salt, this.signer);\n    \n    return factory.createAccountInstance(result.accountAddress);\n  }\n\n  /**\n   * Deploy a new multi-sig account\n   */\n  async deployMultiSigAccount(\n    owners: Address[],\n    threshold: number,\n    salt: bigint = 0n\n  ): Promise<MultiSigAccount> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for account deployment');\n    }\n\n    const factory = this.createMultiSigAccountFactory();\n    const result = await factory.deployAccount(owners, threshold, salt, this.signer);\n    \n    return factory.createAccountInstance(result.accountAddress, threshold, owners);\n  }\n\n  /**\n   * Get an existing simple account instance\n   */\n  getSimpleAccount(accountAddress: Address): SimpleAccount {\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    return new SimpleAccount(this.provider, accountAddress, entryPointAddress);\n  }\n\n  /**\n   * Get an existing multi-sig account instance\n   */\n  getMultiSigAccount(\n    accountAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ): MultiSigAccount {\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    return new MultiSigAccount(\n      this.provider,\n      accountAddress,\n      entryPointAddress,\n      threshold,\n      signers\n    );\n  }\n\n  /**\n   * Execute a transaction through an account\n   */\n  async executeTransaction(\n    account: SimpleAccount | MultiSigAccount,\n    transaction: TransactionData,\n    signature: HexString,\n    usePaymaster: boolean = false\n  ): Promise<string> {\n    try {\n      let userOp = await account.buildUserOperation(transaction);\n\n      // Add paymaster data if requested\n      if (usePaymaster && this.signer) {\n        const paymaster = this.createVerifyingPaymaster(this.signer);\n        const paymasterData = await paymaster.generatePaymasterData(userOp);\n        userOp.paymasterAndData = paymasterData;\n      }\n\n      // Set signature\n      userOp.signature = signature;\n\n      // Submit to EntryPoint (in real implementation, this would go through a bundler)\n      if (!this.signer) {\n        throw new ConfigError('Signer required for transaction execution');\n      }\n\n      return await this.entryPoint.handleOps([userOp], this.signer.address as Address, this.signer);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute a batch of transactions\n   */\n  async executeBatchTransaction(\n    account: SimpleAccount | MultiSigAccount,\n    batch: BatchTransaction,\n    signature: HexString,\n    usePaymaster: boolean = false\n  ): Promise<string> {\n    try {\n      // For batch transactions, paymaster support would need to be implemented\n      // at the account level. For now, we acknowledge the parameter.\n      if (usePaymaster && !this.signer) {\n        throw new ConfigError('Signer required for paymaster operations');\n      }\n      \n      const result = await account.executeBatch(batch, signature);\n      return result.txHash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute batch transaction',\n        { error, batch }\n      );\n    }\n  }\n\n  /**\n   * Estimate gas for a user operation\n   */\n  async estimateUserOpGas(userOp: UserOperation): Promise<{\n    callGasLimit: bigint;\n    verificationGasLimit: bigint;\n    preVerificationGas: bigint;\n  }> {\n    return this.entryPoint.estimateUserOpGas(userOp);\n  }\n\n  /**\n   * Get the hash of a user operation\n   */\n  async getUserOpHash(userOp: UserOperation): Promise<HexString> {\n    return this.entryPoint.getUserOpHash(userOp);\n  }\n\n  /**\n   * Validate a user operation\n   */\n  async validateUserOp(userOp: UserOperation): Promise<boolean> {\n    return this.entryPoint.validateUserOp(userOp);\n  }\n\n  /**\n   * Get account balance in the EntryPoint\n   */\n  async getAccountBalance(account: Address): Promise<bigint> {\n    return this.entryPoint.balanceOf(account);\n  }\n\n  /**\n   * Deposit ETH for an account\n   */\n  async depositForAccount(account: Address, amount: bigint): Promise<string> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for deposits');\n    }\n    return this.entryPoint.depositTo(account, amount, this.signer);\n  }\n\n  /**\n   * Withdraw ETH from an account\n   */\n  async withdrawFromAccount(\n    withdrawAddress: Address,\n    amount: bigint\n  ): Promise<string> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for withdrawals');\n    }\n    return this.entryPoint.withdrawTo(withdrawAddress, amount, this.signer);\n  }\n\n  /**\n   * Get the current network configuration\n   */\n  getNetworkConfig(): NetworkConfig {\n    return this.config.network;\n  }\n\n  /**\n   * Update the signer\n   */\n  updateSigner(signer: ethers.Wallet): void {\n    this.signer = signer.connect(this.provider);\n  }\n\n  /**\n   * Get the EntryPoint client\n   */\n  getEntryPoint(): EntryPointClient {\n    return this.entryPoint;\n  }\n} "]}