{"version":3,"sources":["../src/types/index.ts","../src/zk/types.ts","../src/zk/prover.ts","../src/zk/verifier.ts","../src/zk/client.ts","../src/contracts/types.ts","../src/contracts/account.ts","../src/contracts/paymaster.ts","../src/contracts/factory.ts","../src/contracts/entrypoint.ts","../src/contracts/client.ts","../src/utils/validation.ts","../src/utils/formatting.ts","../src/utils/crypto.ts","../src/utils/constants.ts","../src/index.ts"],"names":["z","sha256","ethers","hours"],"mappings":"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","file":"index.js","sourcesContent":["import { z } from 'zod';\n\n// ============================================================================\n// ZK Proof Types\n// ============================================================================\n\n/**\n * Schema for ZK proof output from the Halo2 circuit\n */\nexport const ZkProofOutputSchema = z.object({\n  /** Length of the original input data */\n  len: z.number().int().nonnegative(),\n  /** SHA256 hash of the input as 32-byte array */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n});\n\nexport type ZkProofOutput = z.infer<typeof ZkProofOutputSchema>;\n\n/**\n * Schema for ZK proof generation result with proof bytes\n */\nexport const ZkProofResultSchema = z.object({\n  /** SHA256 hash of the input */\n  hash: z.array(z.number().int().min(0).max(255)).length(32),\n  /** Serialized proof bytes */\n  proof: z.instanceof(Uint8Array),\n  /** Proof generation time in milliseconds */\n  generationTime: z.number().int().nonnegative(),\n});\n\nexport type ZkProofResult = z.infer<typeof ZkProofResultSchema>;\n\n/**\n * Configuration for ZK proof generation\n */\nexport const ZkProofConfigSchema = z.object({\n  /** Circuit size parameter (k value) */\n  circuitK: z.number().int().min(10).max(20).default(14),\n  /** Whether to use cached proving keys */\n  useCachedKeys: z.boolean().default(true),\n  /** Timeout for proof generation in milliseconds */\n  timeout: z.number().int().positive().default(30000),\n});\n\nexport type ZkProofConfig = z.infer<typeof ZkProofConfigSchema>;\n\n// ============================================================================\n// Account Abstraction Types (ERC-4337)\n// ============================================================================\n\n/**\n * Schema for UserOperation as defined in ERC-4337\n */\nexport const UserOperationSchema = z.object({\n  sender: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  nonce: z.bigint(),\n  initCode: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  callGasLimit: z.bigint(),\n  verificationGasLimit: z.bigint(),\n  preVerificationGas: z.bigint(),\n  maxFeePerGas: z.bigint(),\n  maxPriorityFeePerGas: z.bigint(),\n  paymasterAndData: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  signature: z.string().regex(/^0x[a-fA-F0-9]*$/),\n});\n\nexport type UserOperation = z.infer<typeof UserOperationSchema>;\n\n/**\n * Schema for account configuration\n */\nexport const AccountConfigSchema = z.object({\n  /** Account implementation address */\n  implementation: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Account factory address */\n  factory: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Entry point address */\n  entryPoint: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Initial account owner */\n  owner: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Salt for deterministic address generation */\n  salt: z.bigint().default(0n),\n});\n\nexport type AccountConfig = z.infer<typeof AccountConfigSchema>;\n\n/**\n * Schema for multi-signature account configuration\n */\nexport const MultiSigConfigSchema = z.object({\n  /** List of signer addresses */\n  signers: z.array(z.string().regex(/^0x[a-fA-F0-9]{40}$/)).min(1),\n  /** Required number of signatures (threshold) */\n  threshold: z.number().int().positive(),\n  /** Delay for signer management operations in seconds */\n  delay: z.number().int().nonnegative().default(0),\n});\n\nexport type MultiSigConfig = z.infer<typeof MultiSigConfigSchema>;\n\n/**\n * Schema for paymaster configuration\n */\nexport const PaymasterConfigSchema = z.object({\n  /** Paymaster contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Verifying signer for paymaster */\n  signer: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Valid until timestamp */\n  validUntil: z.number().int().nonnegative(),\n  /** Valid after timestamp */\n  validAfter: z.number().int().nonnegative(),\n});\n\nexport type PaymasterConfig = z.infer<typeof PaymasterConfigSchema>;\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\n/**\n * Schema for transaction data\n */\nexport const TransactionDataSchema = z.object({\n  /** Target contract address */\n  to: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Value in wei */\n  value: z.bigint().default(0n),\n  /** Call data */\n  data: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Operation type (0 = call, 1 = delegatecall) */\n  operation: z.number().int().min(0).max(1).default(0),\n});\n\nexport type TransactionData = z.infer<typeof TransactionDataSchema>;\n\n/**\n * Schema for batch transaction\n */\nexport const BatchTransactionSchema = z.object({\n  /** Array of transaction data */\n  transactions: z.array(TransactionDataSchema).min(1),\n  /** Whether to fail on first error */\n  failOnError: z.boolean().default(true),\n});\n\nexport type BatchTransaction = z.infer<typeof BatchTransactionSchema>;\n\n// ============================================================================\n// Network Types\n// ============================================================================\n\n/**\n * Schema for network configuration\n */\nexport const NetworkConfigSchema = z.object({\n  /** Chain ID */\n  chainId: z.number().int().positive(),\n  /** Network name */\n  name: z.string().min(1),\n  /** RPC URL */\n  rpcUrl: z.string().url(),\n  /** Block explorer URL */\n  explorerUrl: z.string().url().optional(),\n  /** Native currency symbol */\n  currency: z.string().min(1).default('ETH'),\n  /** Whether this is a testnet */\n  isTestnet: z.boolean().default(false),\n});\n\nexport type NetworkConfig = z.infer<typeof NetworkConfigSchema>;\n\n// ============================================================================\n// SDK Configuration Types\n// ============================================================================\n\n/**\n * Schema for SDK configuration\n */\nexport const SdkConfigSchema = z.object({\n  /** Network configuration */\n  network: NetworkConfigSchema,\n  /** ZK proof configuration */\n  zkConfig: ZkProofConfigSchema.optional(),\n  /** Account configuration */\n  accountConfig: AccountConfigSchema.optional(),\n  /** Paymaster configuration */\n  paymasterConfig: PaymasterConfigSchema.optional(),\n  /** Enable debug logging */\n  debug: z.boolean().default(false),\n});\n\nexport type SdkConfig = z.infer<typeof SdkConfigSchema>;\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/**\n * Base error class for Guardian-AA SDK\n */\nexport class GuardianAAError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = 'GuardianAAError';\n  }\n}\n\n/**\n * ZK proof related errors\n */\nexport class ZkProofError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'ZK_PROOF_ERROR', details);\n    this.name = 'ZkProofError';\n  }\n}\n\n/**\n * Contract interaction errors\n */\nexport class ContractError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONTRACT_ERROR', details);\n    this.name = 'ContractError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends GuardianAAError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Result type for operations that can fail\n */\nexport type Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\n/**\n * Async result type\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>;\n\n/**\n * Hex string type\n */\nexport type HexString = `0x${string}`;\n\n/**\n * Address type (20-byte hex string)\n */\nexport type Address = `0x${string}`;\n\n/**\n * Bytes32 type (32-byte hex string)\n */\nexport type Bytes32 = `0x${string}`;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Default gas limits for various operations\n */\nexport const DEFAULT_GAS_LIMITS = {\n  VERIFICATION: 70000n,\n  CALL: 35000n,\n  CREATION: 1000000n,\n  PRE_VERIFICATION: 21000n,\n} as const;\n\n/**\n * Supported chain IDs\n */\nexport const SUPPORTED_CHAINS = {\n  ETHEREUM_MAINNET: 1,\n  ETHEREUM_SEPOLIA: 11155111,\n  POLYGON_MAINNET: 137,\n  POLYGON_MUMBAI: 80001,\n  ARBITRUM_ONE: 42161,\n  ARBITRUM_SEPOLIA: 421614,\n  OPTIMISM_MAINNET: 10,\n  OPTIMISM_SEPOLIA: 11155420,\n} as const;\n\n/**\n * Contract addresses for different chains\n */\nexport type ContractAddresses = {\n  entryPoint: Address;\n  accountFactory: Address;\n  multiSigFactory: Address;\n  verifyingPaymaster: Address;\n};\n\nexport const CONTRACT_ADDRESSES: Record<number, ContractAddresses> = {\n  // Ethereum Sepolia\n  [SUPPORTED_CHAINS.ETHEREUM_SEPOLIA]: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n    accountFactory: '0x9406Cc6185a346906296840746125a0E44976454',\n    multiSigFactory: '0x000000000000000000000000000000000000dEaD',\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD',\n  },\n  // Add more chains as needed\n}; ","import { z } from 'zod';\n\n/**\n * FFI interface types for the Rust prover\n */\nexport interface FFIInput {\n  data: Uint8Array;\n  len: number;\n}\n\nexport interface FFIOutput {\n  len: number;\n  hash: number[];\n}\n\n/**\n * Prover performance metrics\n */\nexport const ProverMetricsSchema = z.object({\n  setupTime: z.number().nonnegative(),\n  proofTime: z.number().nonnegative(),\n  verificationTime: z.number().nonnegative(),\n  proofSize: z.number().int().nonnegative(),\n  circuitSize: z.number().int().nonnegative(),\n});\n\nexport type ProverMetrics = z.infer<typeof ProverMetricsSchema>;\n\n/**\n * Proof verification status\n */\nexport const VerificationStatusSchema = z.enum([\n  'VALID',\n  'INVALID', \n  'ERROR',\n  'TIMEOUT',\n]);\n\nexport type VerificationStatus = z.infer<typeof VerificationStatusSchema>;\n\n/**\n * Proof verification result\n */\nexport const VerificationResultSchema = z.object({\n  status: VerificationStatusSchema,\n  message: z.string().optional(),\n  verificationTime: z.number().nonnegative().optional(),\n  publicInputsHash: z.string().optional(),\n});\n\nexport type VerificationResult = z.infer<typeof VerificationResultSchema>;\n\n/**\n * Prover configuration extending base ZkProofConfig\n */\nexport const ProverConfigSchema = z.object({\n  circuitK: z.number().int().min(10).max(20).default(14),\n  useCachedKeys: z.boolean().default(true),\n  timeout: z.number().int().positive().default(30000),\n  maxInputSize: z.number().int().positive().default(1024 * 1024), // 1MB\n  enableBenchmarking: z.boolean().default(false),\n  logLevel: z.enum(['ERROR', 'WARN', 'INFO', 'DEBUG']).default('INFO'),\n});\n\nexport type ProverConfig = z.infer<typeof ProverConfigSchema>;\n\n/**\n * Proving key cache information\n */\nexport const ProvingKeyCacheSchema = z.object({\n  circuitK: z.number().int(),\n  keyHash: z.string(),\n  createdAt: z.number().int(),\n  size: z.number().int(),\n  isValid: z.boolean(),\n});\n\nexport type ProvingKeyCache = z.infer<typeof ProvingKeyCacheSchema>;\n\n/**\n * Circuit statistics\n */\nexport const CircuitStatsSchema = z.object({\n  numConstraints: z.number().int().nonnegative(),\n  numAdvice: z.number().int().nonnegative(),\n  numFixed: z.number().int().nonnegative(),\n  numInstance: z.number().int().nonnegative(),\n  degree: z.number().int().nonnegative(),\n});\n\nexport type CircuitStats = z.infer<typeof CircuitStatsSchema>;\n\n/**\n * Proof batch for multiple inputs\n */\nexport const ProofBatchSchema = z.object({\n  inputs: z.array(z.instanceof(Uint8Array)).min(1),\n  parallelization: z.boolean().default(true),\n  batchId: z.string().optional(),\n});\n\nexport type ProofBatch = z.infer<typeof ProofBatchSchema>;\n\n/**\n * Batch proof result\n */\nexport const BatchProofResultSchema = z.object({\n  batchId: z.string().optional(),\n  results: z.array(z.object({\n    index: z.number().int().nonnegative(),\n    hash: z.array(z.number().int().min(0).max(255)).length(32),\n    proof: z.instanceof(Uint8Array),\n    generationTime: z.number().nonnegative(),\n  })),\n  totalTime: z.number().nonnegative(),\n  averageTime: z.number().nonnegative(),\n});\n\nexport type BatchProofResult = z.infer<typeof BatchProofResultSchema>;\n\n/**\n * Constants for ZK operations\n */\nexport const ZK_CONSTANTS = {\n  MAX_CIRCUIT_K: 20,\n  MIN_CIRCUIT_K: 10,\n  DEFAULT_CIRCUIT_K: 14,\n  MAX_INPUT_SIZE: 1024 * 1024, // 1MB\n  SHA256_HASH_SIZE: 32,\n  TARGET_PROOF_TIME_MS: 500,\n  MAX_PROOF_TIME_MS: 30000,\n  PROOF_CACHE_TTL_MS: 24 * 60 * 60 * 1000, // 24 hours\n} as const;\n\n/**\n * Error codes specific to ZK operations\n */\nexport const ZK_ERROR_CODES = {\n  PROVER_NOT_INITIALIZED: 'PROVER_NOT_INITIALIZED',\n  INVALID_INPUT_SIZE: 'INVALID_INPUT_SIZE',\n  PROOF_GENERATION_FAILED: 'PROOF_GENERATION_FAILED',\n  VERIFICATION_FAILED: 'VERIFICATION_FAILED',\n  TIMEOUT_EXCEEDED: 'TIMEOUT_EXCEEDED',\n  INVALID_CIRCUIT_K: 'INVALID_CIRCUIT_K',\n  PROVING_KEY_NOT_FOUND: 'PROVING_KEY_NOT_FOUND',\n  FFI_ERROR: 'FFI_ERROR',\n} as const;\n\nexport type ZkErrorCode = keyof typeof ZK_ERROR_CODES; ","import { sha256 } from '@noble/hashes/sha256';\nimport { ZkProofError } from '../types';\nimport {\n  ProverConfig,\n  ProverConfigSchema,\n  ProverMetrics,\n  ZK_CONSTANTS,\n  ZK_ERROR_CODES,\n  ProofBatch,\n  BatchProofResult,\n} from './types';\n\n/**\n * ZK Prover class that interfaces with the Rust guardian_zkml library\n */\nexport class ZkProver {\n  private config: ProverConfig;\n  private isInitialized = false;\n  private setupTime = 0;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.config = ProverConfigSchema.parse(config);\n  }\n\n  /**\n   * Initialize the prover (setup proving keys, etc.)\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // In a real implementation, this would load the Rust WASM module\n      // or initialize FFI bindings to the guardian_zkml library\n      await this.setupProvingSystem();\n      \n      this.setupTime = performance.now() - startTime;\n      this.isInitialized = true;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Prover initialization', this.setupTime);\n      }\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK prover',\n        { error, config: this.config }\n      );\n    }\n  }\n\n  /**\n   * Generate a ZK proof for the given input data\n   */\n  async generateProof(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n    generationTime: number;\n  }> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Prover not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    if (input.length > this.config.maxInputSize) {\n      throw new ZkProofError(\n        `Input size ${input.length} exceeds maximum ${this.config.maxInputSize}`,\n        { code: ZK_ERROR_CODES.INVALID_INPUT_SIZE }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // For now, we'll simulate the proof generation\n      // In the real implementation, this would call the Rust FFI\n      const result = await this.callRustProver(input);\n      \n      const generationTime = performance.now() - startTime;\n\n      if (generationTime > ZK_CONSTANTS.TARGET_PROOF_TIME_MS) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Proof generation time ${generationTime}ms exceeds target ${ZK_CONSTANTS.TARGET_PROOF_TIME_MS}ms`\n        );\n      }\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof generation', generationTime);\n      }\n\n      return {\n        hash: result.hash,\n        proof: result.proof,\n        generationTime,\n      };\n    } catch (error) {\n      throw new ZkProofError(\n        'Proof generation failed',\n        { error, inputSize: input.length }\n      );\n    }\n  }\n\n  /**\n   * Generate proofs for multiple inputs in batch\n   */\n  async generateBatchProofs(batch: ProofBatch): Promise<BatchProofResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Prover not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n    const results = [];\n\n    try {\n      if (batch.parallelization) {\n        // Generate proofs in parallel\n        const promises = batch.inputs.map(async (input, index) => {\n          const result = await this.generateProof(input);\n          return { index, ...result };\n        });\n\n        const parallelResults = await Promise.all(promises);\n        results.push(...parallelResults);\n      } else {\n        // Generate proofs sequentially\n        for (let i = 0; i < batch.inputs.length; i += 1) {\n          const result = await this.generateProof(batch.inputs[i]!);\n          results.push({ index: i, ...result });\n        }\n      }\n\n      const totalTime = performance.now() - startTime;\n      const averageTime = totalTime / batch.inputs.length;\n\n      return {\n        batchId: batch.batchId,\n        results,\n        totalTime,\n        averageTime,\n      };\n    } catch (error) {\n      throw new ZkProofError(\n        'Batch proof generation failed',\n        { error, batchSize: batch.inputs.length }\n      );\n    }\n  }\n\n  /**\n   * Get prover performance metrics\n   */\n  getMetrics(): ProverMetrics {\n    return {\n      setupTime: this.setupTime,\n      proofTime: 0, // Would be calculated from actual measurements\n      verificationTime: 0,\n      proofSize: 0,\n      circuitSize: 2 ** this.config.circuitK,\n    };\n  }\n\n  /**\n   * Update prover configuration\n   */\n  updateConfig(newConfig: Partial<ProverConfig>): void {\n    const updatedConfig = { ...this.config, ...newConfig };\n    this.config = ProverConfigSchema.parse(updatedConfig);\n  }\n\n  /**\n   * Check if prover is initialized\n   */\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    // In real implementation, this would clean up FFI resources\n    this.isInitialized = false;\n    this.setupTime = 0;\n  }\n\n  /**\n   * Private method to setup the proving system\n   */\n  private async setupProvingSystem(): Promise<void> {\n    // Simulate proving system setup\n    // In real implementation, this would:\n    // 1. Load or generate proving keys\n    // 2. Initialize the Halo2 circuit\n    // 3. Setup universal SRS if needed\n    \n    await this.delay(100); // Simulate setup time\n  }\n\n  /**\n   * Private method to call the Rust prover via FFI\n   */\n  private async callRustProver(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n  }> {\n    // Simulate the actual FFI call to guardian_zkml\n    // In real implementation, this would:\n    // 1. Convert JS Uint8Array to FFI-compatible format\n    // 2. Call the Rust generate_proof_with_proof function\n    // 3. Convert the result back to JS types\n\n    // For now, compute the actual SHA256 hash\n    const hashBuffer = sha256(input);\n    const hash = Array.from(hashBuffer);\n\n    // Simulate proof bytes (in real implementation, this comes from Halo2)\n    const proof = new Uint8Array(1024); // Typical Halo2 proof size\n    crypto.getRandomValues(proof);\n\n    // Simulate proof generation time\n    await this.delay(50);\n\n    return { hash, proof };\n  }\n\n  /**\n   * Utility method for simulating async operations\n   */\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  /**\n   * Log performance metrics\n   */\n  private logPerformance(operation: string, timeMs: number): void {\n    if (this.config.logLevel === 'DEBUG' || this.config.logLevel === 'INFO') {\n      // eslint-disable-next-line no-console\n      console.log(`[ZkProver] ${operation}: ${timeMs.toFixed(2)}ms`);\n    }\n  }\n} ","import { sha256 } from '@noble/hashes/sha256';\nimport { ZkProofError } from '../types';\nimport {\n  VerificationResult,\n  VerificationStatus,\n  ProverConfig,\n  ZK_ERROR_CODES,\n} from './types';\n\n/**\n * ZK Verifier class for verifying zero-knowledge proofs\n */\nexport class ZkVerifier {\n  private config: ProverConfig;\n  private isInitialized = false;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.config = {\n      circuitK: 14,\n      useCachedKeys: true,\n      timeout: 30000,\n      maxInputSize: 1024 * 1024,\n      enableBenchmarking: false,\n      logLevel: 'INFO',\n      ...config,\n    };\n  }\n\n  /**\n   * Initialize the verifier\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // In real implementation, this would load verifying keys\n      await this.setupVerificationSystem();\n      this.isInitialized = true;\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK verifier',\n        { error, config: this.config }\n      );\n    }\n  }\n\n  /**\n   * Verify a ZK proof against the original input\n   */\n  async verifyProof(\n    input: Uint8Array,\n    proof: Uint8Array,\n    expectedHash: number[]\n  ): Promise<VerificationResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // First, verify the hash matches\n      const computedHashBuffer = sha256(input);\n      const computedHash = Array.from(computedHashBuffer);\n\n      if (!this.arraysEqual(computedHash, expectedHash)) {\n        return {\n          status: 'INVALID' as VerificationStatus,\n          message: 'Hash mismatch',\n          verificationTime: performance.now() - startTime,\n        };\n      }\n\n      // In real implementation, this would verify the ZK proof\n      const isValidProof = await this.verifyZkProof(proof, expectedHash);\n      const verificationTime = performance.now() - startTime;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof verification', verificationTime);\n      }\n\n      return {\n        status: isValidProof ? 'VALID' : 'INVALID',\n        verificationTime,\n        publicInputsHash: this.arrayToHex(expectedHash),\n      };\n    } catch (error) {\n      return {\n        status: 'ERROR' as VerificationStatus,\n        message: error instanceof Error ? error.message : 'Unknown error',\n        verificationTime: performance.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Verify only the proof (without re-computing the hash)\n   */\n  async verifyProofOnly(\n    proof: Uint8Array,\n    publicInputs: number[]\n  ): Promise<VerificationResult> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const startTime = performance.now();\n\n    try {\n      const isValid = await this.verifyZkProof(proof, publicInputs);\n      const verificationTime = performance.now() - startTime;\n\n      if (this.config.enableBenchmarking) {\n        this.logPerformance('Proof-only verification', verificationTime);\n      }\n\n      return {\n        status: isValid ? 'VALID' : 'INVALID',\n        verificationTime,\n        publicInputsHash: this.arrayToHex(publicInputs),\n      };\n    } catch (error) {\n      return {\n        status: 'ERROR' as VerificationStatus,\n        message: error instanceof Error ? error.message : 'Unknown error',\n        verificationTime: performance.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * Batch verify multiple proofs\n   */\n  async verifyBatchProofs(\n    proofs: Array<{\n      input: Uint8Array;\n      proof: Uint8Array;\n      expectedHash: number[];\n    }>\n  ): Promise<VerificationResult[]> {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'Verifier not initialized',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n\n    const promises = proofs.map(({ input, proof, expectedHash }) =>\n      this.verifyProof(input, proof, expectedHash)\n    );\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Check if verifier is ready\n   */\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    this.isInitialized = false;\n  }\n\n  /**\n   * Private method to setup verification system\n   */\n  private async setupVerificationSystem(): Promise<void> {\n    // Simulate verification system setup\n    // In real implementation, this would load verifying keys\n    await this.delay(50);\n  }\n\n  /**\n   * Private method to verify the ZK proof\n   */\n  private async verifyZkProof(\n    proof: Uint8Array,\n    publicInputs: number[]\n  ): Promise<boolean> {\n    // Simulate ZK proof verification\n    // In real implementation, this would:\n    // 1. Call the Rust verify_proof_with_proof function\n    // 2. Use the loaded verifying key and public inputs\n    // 3. Return the verification result\n\n    await this.delay(10); // Simulate verification time\n\n    // For demonstration, we'll do a basic check\n    return proof.length > 0 && publicInputs.length === 32;\n  }\n\n  /**\n   * Utility method to compare arrays\n   */\n  private arraysEqual(a: number[], b: number[]): boolean {\n    if (a.length !== b.length) return false;\n    return a.every((val, index) => val === b[index]);\n  }\n\n  /**\n   * Convert number array to hex string\n   */\n  private arrayToHex(arr: number[]): string {\n    return `0x${arr.map((b) => b.toString(16).padStart(2, '0')).join('')}`;\n  }\n\n  /**\n   * Utility method for simulating async operations\n   */\n  private async delay(ms: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  /**\n   * Log performance metrics\n   */\n  private logPerformance(operation: string, timeMs: number): void {\n    if (this.config.logLevel === 'DEBUG' || this.config.logLevel === 'INFO') {\n      // eslint-disable-next-line no-console\n      console.log(`[ZkVerifier] ${operation}: ${timeMs.toFixed(2)}ms`);\n    }\n  }\n} ","import { ZkProver } from './prover';\nimport { ZkVerifier } from './verifier';\nimport { ZkProofError } from '../types';\nimport {\n  ProverConfig,\n  VerificationResult,\n  ProofBatch,\n  BatchProofResult,\n  ZK_ERROR_CODES,\n} from './types';\n\n/**\n * High-level ZK client that combines prover and verifier functionality\n */\nexport class ZkClient {\n  private prover: ZkProver;\n  private verifier: ZkVerifier;\n  private isInitialized = false;\n\n  constructor(config: Partial<ProverConfig> = {}) {\n    this.prover = new ZkProver(config);\n    this.verifier = new ZkVerifier(config);\n  }\n\n  /**\n   * Initialize both prover and verifier\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      await Promise.all([\n        this.prover.initialize(),\n        this.verifier.initialize(),\n      ]);\n      this.isInitialized = true;\n    } catch (error) {\n      throw new ZkProofError(\n        'Failed to initialize ZK client',\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Generate a proof for input data\n   */\n  async generateProof(input: Uint8Array): Promise<{\n    hash: number[];\n    proof: Uint8Array;\n    generationTime: number;\n  }> {\n    this.ensureInitialized();\n    return this.prover.generateProof(input);\n  }\n\n  /**\n   * Verify a proof against the original input\n   */\n  async verifyProof(\n    input: Uint8Array,\n    proof: Uint8Array,\n    expectedHash: number[]\n  ): Promise<VerificationResult> {\n    this.ensureInitialized();\n    return this.verifier.verifyProof(input, proof, expectedHash);\n  }\n\n  /**\n   * Generate and verify a proof in one operation\n   */\n  async proveAndVerify(input: Uint8Array): Promise<{\n    proof: {\n      hash: number[];\n      proof: Uint8Array;\n      generationTime: number;\n    };\n    verification: VerificationResult;\n  }> {\n    this.ensureInitialized();\n\n    const proof = await this.generateProof(input);\n    const verification = await this.verifyProof(\n      input,\n      proof.proof,\n      proof.hash\n    );\n\n    return { proof, verification };\n  }\n\n  /**\n   * Generate proofs for multiple inputs\n   */\n  async generateBatchProofs(batch: ProofBatch): Promise<BatchProofResult> {\n    this.ensureInitialized();\n    return this.prover.generateBatchProofs(batch);\n  }\n\n  /**\n   * Verify multiple proofs\n   */\n  async verifyBatchProofs(\n    proofs: Array<{\n      input: Uint8Array;\n      proof: Uint8Array;\n      expectedHash: number[];\n    }>\n  ): Promise<VerificationResult[]> {\n    this.ensureInitialized();\n    return this.verifier.verifyBatchProofs(proofs);\n  }\n\n  /**\n   * Get performance metrics from the prover\n   */\n  getMetrics(): {\n    setupTime: number;\n    proofTime: number;\n    verificationTime: number;\n    proofSize: number;\n    circuitSize: number;\n  } {\n    this.ensureInitialized();\n    return this.prover.getMetrics();\n  }\n\n  /**\n   * Check if the client is ready\n   */\n  isReady(): boolean {\n    return this.isInitialized && \n           this.prover.isReady() && \n           this.verifier.isReady();\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    await Promise.all([\n      this.prover.cleanup(),\n      this.verifier.cleanup(),\n    ]);\n    this.isInitialized = false;\n  }\n\n  /**\n   * Update configuration for both prover and verifier\n   */\n  updateConfig(newConfig: Partial<ProverConfig>): void {\n    this.prover.updateConfig(newConfig);\n    // Note: Verifier doesn't have updateConfig method in current implementation\n  }\n\n  /**\n   * Ensure the client is initialized\n   */\n  private ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new ZkProofError(\n        'ZK client not initialized. Call initialize() first.',\n        { code: ZK_ERROR_CODES.PROVER_NOT_INITIALIZED }\n      );\n    }\n  }\n} ","import { z } from 'zod';\nimport type { Address } from '../types';\n\n// ============================================================================\n// Contract ABI Types\n// ============================================================================\n\n/**\n * Entry Point contract ABI (simplified)\n */\nexport const ENTRY_POINT_ABI = [\n  {\n    name: 'handleOps',\n    type: 'function',\n    inputs: [\n      { name: 'ops', type: 'tuple[]', components: [] },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getUserOpHash',\n    type: 'function',\n    inputs: [{ name: 'userOp', type: 'tuple', components: [] }],\n    outputs: [{ name: '', type: 'bytes32' }],\n  },\n] as const;\n\n/**\n * Simple Account contract ABI (simplified)\n */\nexport const SIMPLE_ACCOUNT_ABI = [\n  {\n    name: 'execute',\n    type: 'function',\n    inputs: [\n      { name: 'dest', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'func', type: 'bytes' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'executeBatch',\n    type: 'function',\n    inputs: [\n      { name: 'dest', type: 'address[]' },\n      { name: 'value', type: 'uint256[]' },\n      { name: 'func', type: 'bytes[]' },\n    ],\n    outputs: [],\n  },\n] as const;\n\n/**\n * Multi-Sig Account contract ABI (simplified)\n */\nexport const MULTI_SIG_ACCOUNT_ABI = [\n  {\n    name: 'addSigner',\n    type: 'function',\n    inputs: [{ name: 'signer', type: 'address' }],\n    outputs: [],\n  },\n  {\n    name: 'removeSigner',\n    type: 'function',\n    inputs: [{ name: 'signer', type: 'address' }],\n    outputs: [],\n  },\n  {\n    name: 'changeThreshold',\n    type: 'function',\n    inputs: [{ name: 'threshold', type: 'uint256' }],\n    outputs: [],\n  },\n] as const;\n\n/**\n * Verifying Paymaster contract ABI (simplified)\n */\nexport const VERIFYING_PAYMASTER_ABI = [\n  {\n    name: 'getHash',\n    type: 'function',\n    inputs: [\n      { name: 'userOp', type: 'tuple', components: [] },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'validAfter', type: 'uint48' },\n    ],\n    outputs: [{ name: '', type: 'bytes32' }],\n  },\n] as const;\n\n// ============================================================================\n// Contract Configuration Types\n// ============================================================================\n\n/**\n * Contract deployment configuration\n */\nexport const ContractDeployConfigSchema = z.object({\n  /** Contract bytecode */\n  bytecode: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Constructor arguments */\n  constructorArgs: z.array(z.unknown()).default([]),\n  /** Gas limit for deployment */\n  gasLimit: z.bigint().optional(),\n  /** Gas price */\n  gasPrice: z.bigint().optional(),\n  /** Salt for CREATE2 deployment */\n  salt: z.string().regex(/^0x[a-fA-F0-9]{64}$/).optional(),\n});\n\nexport type ContractDeployConfig = z.infer<typeof ContractDeployConfigSchema>;\n\n/**\n * Contract interaction configuration\n */\nexport const ContractCallConfigSchema = z.object({\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Function name */\n  functionName: z.string().min(1),\n  /** Function arguments */\n  args: z.array(z.unknown()).default([]),\n  /** Value to send with the call */\n  value: z.bigint().default(0n),\n  /** Gas limit */\n  gasLimit: z.bigint().optional(),\n});\n\nexport type ContractCallConfig = z.infer<typeof ContractCallConfigSchema>;\n\n// ============================================================================\n// Account Operation Types\n// ============================================================================\n\n/**\n * Account operation result\n */\nexport const AccountOperationResultSchema = z.object({\n  /** Transaction hash */\n  txHash: z.string().regex(/^0x[a-fA-F0-9]{64}$/),\n  /** Block number */\n  blockNumber: z.number().int().nonnegative(),\n  /** Gas used */\n  gasUsed: z.bigint(),\n  /** Operation status */\n  status: z.enum(['SUCCESS', 'FAILED', 'PENDING']),\n  /** Error message if failed */\n  error: z.string().optional(),\n});\n\nexport type AccountOperationResult = z.infer<typeof AccountOperationResultSchema>;\n\n/**\n * Signature data for multi-sig operations\n */\nexport const SignatureDataSchema = z.object({\n  /** Signer address */\n  signer: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Signature bytes */\n  signature: z.string().regex(/^0x[a-fA-F0-9]*$/),\n  /** Signature type (ECDSA, etc.) */\n  signatureType: z.enum(['ECDSA', 'EIP1271']).default('ECDSA'),\n});\n\nexport type SignatureData = z.infer<typeof SignatureDataSchema>;\n\n// ============================================================================\n// Gas Estimation Types\n// ============================================================================\n\n/**\n * Gas estimation result\n */\nexport const GasEstimationSchema = z.object({\n  /** Estimated gas limit */\n  gasLimit: z.bigint(),\n  /** Estimated gas price */\n  gasPrice: z.bigint(),\n  /** Maximum fee per gas (EIP-1559) */\n  maxFeePerGas: z.bigint().optional(),\n  /** Maximum priority fee per gas (EIP-1559) */\n  maxPriorityFeePerGas: z.bigint().optional(),\n  /** Estimated total cost in wei */\n  totalCost: z.bigint(),\n});\n\nexport type GasEstimation = z.infer<typeof GasEstimationSchema>;\n\n// ============================================================================\n// Event Types\n// ============================================================================\n\n/**\n * Contract event filter\n */\nexport const EventFilterSchema = z.object({\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Event topics */\n  topics: z.array(z.string().regex(/^0x[a-fA-F0-9]{64}$/)).optional(),\n  /** From block */\n  fromBlock: z.union([z.number().int().nonnegative(), z.literal('latest')]).default('latest'),\n  /** To block */\n  toBlock: z.union([z.number().int().nonnegative(), z.literal('latest')]).default('latest'),\n});\n\nexport type EventFilter = z.infer<typeof EventFilterSchema>;\n\n/**\n * Contract event log\n */\nexport const ContractEventSchema = z.object({\n  /** Event name */\n  eventName: z.string(),\n  /** Contract address */\n  address: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  /** Block number */\n  blockNumber: z.number().int().nonnegative(),\n  /** Transaction hash */\n  transactionHash: z.string().regex(/^0x[a-fA-F0-9]{64}$/),\n  /** Event data */\n  data: z.record(z.unknown()),\n});\n\nexport type ContractEvent = z.infer<typeof ContractEventSchema>;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Default contract addresses for supported networks\n */\nexport const DEFAULT_CONTRACT_ADDRESSES: Record<number, {\n  entryPoint: Address;\n  simpleAccountFactory: Address;\n  multiSigAccountFactory: Address;\n  verifyingPaymaster: Address;\n}> = {\n  // Local testnet (Hardhat/Anvil)\n  31337: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as Address,\n    simpleAccountFactory: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0' as Address,\n    multiSigAccountFactory: '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9' as Address,\n    verifyingPaymaster: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9' as Address,\n  },\n  // Ethereum Sepolia\n  11155111: {\n    entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as Address,\n    simpleAccountFactory: '0x9406Cc6185a346906296840746125a0E44976454' as Address,\n    multiSigAccountFactory: '0x000000000000000000000000000000000000dEaD' as Address,\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD' as Address,\n  },\n} as const;\n\n/**\n * Contract deployment gas limits\n */\nexport const CONTRACT_GAS_LIMITS = {\n  SIMPLE_ACCOUNT_DEPLOY: 1000000n,\n  MULTI_SIG_ACCOUNT_DEPLOY: 1500000n,\n  PAYMASTER_DEPLOY: 800000n,\n  ENTRY_POINT_DEPLOY: 2000000n,\n} as const;\n\n/**\n * Function selectors for common operations\n */\nexport const FUNCTION_SELECTORS = {\n  EXECUTE: '0xb61d27f6',\n  EXECUTE_BATCH: '0x18dfb3c7',\n  ADD_SIGNER: '0x7065cb48',\n  REMOVE_SIGNER: '0x0e316ab7',\n  CHANGE_THRESHOLD: '0x694e80c3',\n} as const; ","import { ethers } from 'ethers';\nimport { ContractError, ValidationError } from '../types';\nimport type { \n  UserOperation, \n  TransactionData, \n  BatchTransaction,\n  Address,\n  HexString,\n} from '../types';\nimport {\n  AccountOperationResult,\n  SignatureData,\n  GasEstimation,\n  SIMPLE_ACCOUNT_ABI,\n  MULTI_SIG_ACCOUNT_ABI,\n  CONTRACT_GAS_LIMITS,\n} from './types';\n\n/**\n * Base class for account abstraction wallets\n */\nexport abstract class BaseAccount {\n  protected provider: ethers.Provider;\n  protected address: Address;\n  protected entryPointAddress: Address;\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address\n  ) {\n    this.provider = provider;\n    this.address = address;\n    this.entryPointAddress = entryPointAddress;\n  }\n\n  /**\n   * Get the account address\n   */\n  getAddress(): Address {\n    return this.address;\n  }\n\n  /**\n   * Get the current nonce for the account\n   */\n  async getNonce(): Promise<bigint> {\n    try {\n      const contract = new ethers.Contract(\n        this.address,\n        ['function getNonce() view returns (uint256)'],\n        this.provider\n      );\n      \n      const getNonceMethod = contract['getNonce'];\n      if (!getNonceMethod) {\n        throw new Error('getNonce method not found on contract');\n      }\n      \n      const result = await getNonceMethod();\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get account nonce',\n        { error, address: this.address }\n      );\n    }\n  }\n\n  /**\n   * Estimate gas for a transaction\n   */\n  async estimateGas(transaction: TransactionData): Promise<GasEstimation> {\n    try {\n      const feeData = await this.provider.getFeeData();\n      const gasLimit = await this.provider.estimateGas({\n        to: transaction.to,\n        value: transaction.value,\n        data: transaction.data,\n      });\n\n      const gasPrice = feeData.gasPrice ?? 0n;\n      const maxFeePerGas = feeData.maxFeePerGas ?? gasPrice;\n      const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? 0n;\n\n      return {\n        gasLimit: gasLimit + (gasLimit / 10n), // Add 10% buffer\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        totalCost: gasLimit * gasPrice,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to estimate gas',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Build a UserOperation for the given transaction\n   */\n  abstract buildUserOperation(\n    transaction: TransactionData,\n    options?: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    }\n  ): Promise<UserOperation>;\n\n  /**\n   * Execute a single transaction\n   */\n  abstract execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult>;\n\n  /**\n   * Execute multiple transactions in batch\n   */\n  abstract executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult>;\n}\n\n/**\n * Simple Account implementation (ECDSA signature-based)\n */\nexport class SimpleAccount extends BaseAccount {\n  private contract: ethers.Contract;\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address\n  ) {\n    super(provider, address, entryPointAddress);\n    this.contract = new ethers.Contract(address, SIMPLE_ACCOUNT_ABI, provider);\n  }\n\n  /**\n   * Build a UserOperation for a simple account transaction\n   */\n  async buildUserOperation(\n    transaction: TransactionData,\n    options: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    } = {}\n  ): Promise<UserOperation> {\n    try {\n      const nonce = options.nonce ?? await this.getNonce();\n      const gasEstimation = await this.estimateGas(transaction);\n\n      // Encode the execute function call\n      const callData = this.contract.interface.encodeFunctionData('execute', [\n        transaction.to,\n        transaction.value,\n        transaction.data,\n      ]);\n\n      return {\n        sender: this.address,\n        nonce,\n        initCode: '0x', // Account already deployed\n        callData,\n        callGasLimit: options.gasLimits?.gasLimit ?? gasEstimation.gasLimit,\n        verificationGasLimit: CONTRACT_GAS_LIMITS.SIMPLE_ACCOUNT_DEPLOY / 10n,\n        preVerificationGas: 21000n,\n        maxFeePerGas: options.gasLimits?.maxFeePerGas ?? gasEstimation.maxFeePerGas ?? 0n,\n        maxPriorityFeePerGas: options.gasLimits?.maxPriorityFeePerGas ?? gasEstimation.maxPriorityFeePerGas ?? 0n,\n        paymasterAndData: options.paymasterData ?? '0x',\n        signature: '0x', // Will be filled by the signer\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to build UserOperation',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute a single transaction\n   */\n  async execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const userOp = await this.buildUserOperation(transaction);\n      userOp.signature = signature;\n\n      // In a real implementation, this would submit to a bundler\n      // For now, we'll simulate the execution\n      const txHash = ethers.keccak256(\n        ethers.toUtf8Bytes(JSON.stringify(userOp))\n      );\n\n      return {\n        txHash: txHash as HexString,\n        blockNumber: await this.provider.getBlockNumber(),\n        gasUsed: userOp.callGasLimit,\n        status: 'SUCCESS',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute multiple transactions in batch\n   */\n  async executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const destinations = batch.transactions.map(tx => tx.to);\n      const values = batch.transactions.map(tx => tx.value);\n      const datas = batch.transactions.map(tx => tx.data);\n\n      // Encode the executeBatch function call\n      const callData = this.contract.interface.encodeFunctionData('executeBatch', [\n        destinations,\n        values,\n        datas,\n      ]);\n\n      const batchTransaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      return this.execute(batchTransaction, signature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute batch transaction',\n        { error, batch }\n      );\n    }\n  }\n}\n\n/**\n * Multi-Signature Account implementation\n */\nexport class MultiSigAccount extends BaseAccount {\n  private contract: ethers.Contract;\n  private threshold: number;\n  private signers: Address[];\n\n  constructor(\n    provider: ethers.Provider,\n    address: Address,\n    entryPointAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ) {\n    super(provider, address, entryPointAddress);\n    this.contract = new ethers.Contract(address, MULTI_SIG_ACCOUNT_ABI, provider);\n    this.threshold = threshold;\n    this.signers = signers;\n  }\n\n  /**\n   * Get current signers and threshold\n   */\n  async getSignerInfo(): Promise<{ signers: Address[]; threshold: number }> {\n    try {\n      // In a real implementation, this would query the contract\n      return {\n        signers: this.signers,\n        threshold: this.threshold,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get signer info',\n        { error, address: this.address }\n      );\n    }\n  }\n\n  /**\n   * Add a new signer to the multi-sig account\n   */\n  async addSigner(\n    newSigner: Address,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('addSigner', [\n        newSigner,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      // Combine signatures for multi-sig verification\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      return this.execute(transaction, combinedSignature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to add signer',\n        { error, newSigner, signatures }\n      );\n    }\n  }\n\n  /**\n   * Remove a signer from the multi-sig account\n   */\n  async removeSigner(\n    signerToRemove: Address,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('removeSigner', [\n        signerToRemove,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      return this.execute(transaction, combinedSignature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to remove signer',\n        { error, signerToRemove, signatures }\n      );\n    }\n  }\n\n  /**\n   * Change the signature threshold\n   */\n  async changeThreshold(\n    newThreshold: number,\n    signatures: SignatureData[]\n  ): Promise<AccountOperationResult> {\n    if (signatures.length < this.threshold) {\n      throw new ValidationError(\n        `Insufficient signatures: need ${this.threshold}, got ${signatures.length}`\n      );\n    }\n\n    if (newThreshold > this.signers.length) {\n      throw new ValidationError(\n        `Threshold ${newThreshold} cannot exceed number of signers ${this.signers.length}`\n      );\n    }\n\n    try {\n      const callData = this.contract.interface.encodeFunctionData('changeThreshold', [\n        newThreshold,\n      ]);\n\n      const transaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      const combinedSignature = this.combineSignatures(signatures);\n      \n      const result = await this.execute(transaction, combinedSignature);\n      \n      // Update local threshold after successful execution\n      this.threshold = newThreshold;\n      \n      return result;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to change threshold',\n        { error, newThreshold, signatures }\n      );\n    }\n  }\n\n  /**\n   * Build UserOperation for multi-sig account\n   */\n  async buildUserOperation(\n    transaction: TransactionData,\n    options: {\n      nonce?: bigint;\n      gasLimits?: Partial<GasEstimation>;\n      paymasterData?: HexString;\n    } = {}\n  ): Promise<UserOperation> {\n    try {\n      const nonce = options.nonce ?? await this.getNonce();\n      const gasEstimation = await this.estimateGas(transaction);\n\n      // Encode the execute function call\n      const callData = this.contract.interface.encodeFunctionData('execute', [\n        transaction.to,\n        transaction.value,\n        transaction.data,\n      ]);\n\n      return {\n        sender: this.address,\n        nonce,\n        initCode: '0x', // Account already deployed\n        callData,\n        callGasLimit: options.gasLimits?.gasLimit ?? gasEstimation.gasLimit,\n        verificationGasLimit: CONTRACT_GAS_LIMITS.MULTI_SIG_ACCOUNT_DEPLOY / 5n,\n        preVerificationGas: 21000n,\n        maxFeePerGas: options.gasLimits?.maxFeePerGas ?? gasEstimation.maxFeePerGas ?? 0n,\n        maxPriorityFeePerGas: options.gasLimits?.maxPriorityFeePerGas ?? gasEstimation.maxPriorityFeePerGas ?? 0n,\n        paymasterAndData: options.paymasterData ?? '0x',\n        signature: '0x', // Will be filled by the signer\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to build UserOperation for multi-sig account',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute with multi-sig verification\n   */\n  async execute(\n    transaction: TransactionData,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const userOp = await this.buildUserOperation(transaction);\n      userOp.signature = signature;\n\n      // In a real implementation, this would submit to a bundler\n      // For now, we'll simulate the execution\n      const txHash = ethers.keccak256(\n        ethers.toUtf8Bytes(JSON.stringify(userOp))\n      );\n\n      return {\n        txHash: txHash as HexString,\n        blockNumber: await this.provider.getBlockNumber(),\n        gasUsed: userOp.callGasLimit,\n        status: 'SUCCESS',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute multi-sig transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute batch with multi-sig verification\n   */\n  async executeBatch(\n    batch: BatchTransaction,\n    signature: HexString\n  ): Promise<AccountOperationResult> {\n    try {\n      const destinations = batch.transactions.map(tx => tx.to);\n      const values = batch.transactions.map(tx => tx.value);\n      const datas = batch.transactions.map(tx => tx.data);\n\n      // Encode the executeBatch function call\n      const callData = this.contract.interface.encodeFunctionData('executeBatch', [\n        destinations,\n        values,\n        datas,\n      ]);\n\n      const batchTransaction: TransactionData = {\n        to: this.address,\n        value: 0n,\n        data: callData,\n        operation: 0,\n      };\n\n      return this.execute(batchTransaction, signature);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute multi-sig batch transaction',\n        { error, batch }\n      );\n    }\n  }\n\n  /**\n   * Combine multiple signatures into a single signature for multi-sig verification\n   */\n  private combineSignatures(signatures: SignatureData[]): HexString {\n    // Sort signatures by signer address to ensure deterministic order\n    const sortedSignatures = signatures.sort((a, b) => \n      a.signer.toLowerCase().localeCompare(b.signer.toLowerCase())\n    );\n\n    // Combine signatures (implementation depends on the multi-sig contract format)\n    const combined = sortedSignatures\n      .map(sig => sig.signature.slice(2)) // Remove 0x prefix\n      .join('');\n\n    return `0x${combined}` as HexString;\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { UserOperation, Address, HexString } from '../types';\nimport { VERIFYING_PAYMASTER_ABI } from './types';\n\n/**\n * Paymaster configuration for gasless transactions\n */\nexport interface ContractPaymasterConfig {\n  address: Address;\n  signer: ethers.Wallet;\n  validUntil: number;\n  validAfter: number;\n}\n\n/**\n * Paymaster signature data\n */\nexport interface PaymasterSignature {\n  validUntil: number;\n  validAfter: number;\n  signature: HexString;\n}\n\n/**\n * Verifying Paymaster implementation for sponsoring user operations\n */\nexport class VerifyingPaymaster {\n  private provider: ethers.Provider;\n  private config: ContractPaymasterConfig;\n\n  constructor(provider: ethers.Provider, config: ContractPaymasterConfig) {\n    this.provider = provider;\n    this.config = config;\n  }\n\n  /**\n   * Generate paymaster data for a user operation\n   */\n  async generatePaymasterData(\n    userOp: UserOperation,\n    validUntil?: number,\n    validAfter?: number\n  ): Promise<HexString> {\n    try {\n      const until = validUntil ?? this.config.validUntil;\n      const after = validAfter ?? this.config.validAfter;\n\n      // Get the hash that needs to be signed\n      const hash = await this.getPaymasterHash(userOp, until, after);\n      \n      // Sign the hash\n      const signature = await this.config.signer.signMessage(\n        ethers.getBytes(hash)\n      );\n\n      // Encode paymaster data: address + validUntil + validAfter + signature\n      const paymasterData = ethers.solidityPacked(\n        ['address', 'uint48', 'uint48', 'bytes'],\n        [this.config.address, until, after, signature]\n      );\n\n      return paymasterData as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to generate paymaster data',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Verify if a user operation can be sponsored\n   */\n  async canSponsor(userOp: UserOperation): Promise<boolean> {\n    try {\n      // Check if the paymaster has sufficient balance\n      const balance = await this.getBalance();\n      const estimatedCost = this.estimateOperationCost(userOp);\n\n      if (balance < estimatedCost) {\n        return false;\n      }\n\n      // Additional sponsorship logic can be added here\n      // e.g., whitelist checks, rate limiting, etc.\n      \n      return true;\n    } catch (error) {\n      // If we can't determine sponsorship eligibility, err on the side of caution\n      return false;\n    }\n  }\n\n  /**\n   * Get the paymaster's balance in the EntryPoint\n   */\n  async getBalance(): Promise<bigint> {\n    try {\n      // In a real implementation, this would query the EntryPoint contract\n      // for the paymaster's deposited balance\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789', // Standard EntryPoint address\n        ['function balanceOf(address) view returns (uint256)'],\n        this.provider\n      );\n\n      const balanceOfMethod = entryPointContract['balanceOf'];\n      if (!balanceOfMethod) {\n        throw new Error('balanceOf method not found on contract');\n      }\n      return await balanceOfMethod(this.config.address) as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get paymaster balance',\n        { error, address: this.config.address }\n      );\n    }\n  }\n\n  /**\n   * Deposit funds to the paymaster's EntryPoint balance\n   */\n  async deposit(amount: bigint): Promise<string> {\n    try {\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n        ['function depositTo(address) payable'],\n        this.config.signer\n      );\n\n      const depositToMethod = entryPointContract['depositTo'];\n      if (!depositToMethod) {\n        throw new Error('depositTo method not found on contract');\n      }\n      const tx = await depositToMethod(this.config.address, {\n        value: amount,\n      });\n\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deposit to paymaster',\n        { error, amount }\n      );\n    }\n  }\n\n  /**\n   * Withdraw funds from the paymaster's EntryPoint balance\n   */\n  async withdraw(amount: bigint, to: Address): Promise<string> {\n    try {\n      const entryPointContract = new ethers.Contract(\n        '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',\n        ['function withdrawTo(address, uint256)'],\n        this.config.signer\n      );\n\n      const withdrawToMethod = entryPointContract['withdrawTo'];\n      if (!withdrawToMethod) {\n        throw new Error('withdrawTo method not found on contract');\n      }\n      const tx = await withdrawToMethod(to, amount);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to withdraw from paymaster',\n        { error, amount, to }\n      );\n    }\n  }\n\n  /**\n   * Update paymaster configuration\n   */\n  updateConfig(newConfig: Partial<ContractPaymasterConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get the current paymaster configuration\n   */\n  getConfig(): ContractPaymasterConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get the hash that needs to be signed for paymaster verification\n   */\n  private async getPaymasterHash(\n    userOp: UserOperation,\n    validUntil: number,\n    validAfter: number\n  ): Promise<string> {\n    try {\n      // In a real implementation, this would call the paymaster contract\n      // For now, we'll create a hash manually\n      const encoded = ethers.solidityPacked(\n        ['address', 'uint256', 'bytes32', 'uint48', 'uint48'],\n        [\n          userOp.sender,\n          userOp.nonce,\n          ethers.keccak256(userOp.callData),\n          validUntil,\n          validAfter,\n        ]\n      );\n\n      return ethers.keccak256(encoded);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get paymaster hash',\n        { error, userOp, validUntil, validAfter }\n      );\n    }\n  }\n\n  /**\n   * Estimate the cost of sponsoring a user operation\n   */\n  private estimateOperationCost(userOp: UserOperation): bigint {\n    // Estimate total gas cost including verification and execution\n    const totalGas = userOp.callGasLimit + \n                    userOp.verificationGasLimit + \n                    userOp.preVerificationGas;\n    \n    const gasPrice = userOp.maxFeePerGas;\n    \n    return totalGas * gasPrice;\n  }\n}\n\n/**\n * Factory for creating paymaster instances\n */\nexport class PaymasterFactory {\n  private provider: ethers.Provider;\n\n  constructor(provider: ethers.Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Create a new VerifyingPaymaster instance\n   */\n  createVerifyingPaymaster(config: ContractPaymasterConfig): VerifyingPaymaster {\n    return new VerifyingPaymaster(this.provider, config);\n  }\n\n  /**\n   * Deploy a new paymaster contract\n   */\n  async deployPaymaster(\n    deployer: ethers.Wallet,\n    entryPointAddress: Address,\n    owner: Address\n  ): Promise<{ address: Address; txHash: string }> {\n    try {\n      // In a real implementation, this would deploy the actual paymaster contract\n      // For now, we'll simulate the deployment\n      const factory = new ethers.ContractFactory(\n        VERIFYING_PAYMASTER_ABI,\n        '0x', // Bytecode would be here\n        deployer\n      );\n\n      const contract = await factory.deploy(entryPointAddress, owner);\n      await contract.waitForDeployment();\n\n      return {\n        address: await contract.getAddress() as Address,\n        txHash: contract.deploymentTransaction()?.hash ?? '',\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy paymaster',\n        { error, entryPointAddress, owner }\n      );\n    }\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { Address, HexString } from '../types';\nimport { SimpleAccount, MultiSigAccount } from './account';\n\n/**\n * Account factory configuration\n */\nexport interface AccountFactoryConfig {\n  factoryAddress: Address;\n  entryPointAddress: Address;\n  implementationAddress: Address;\n}\n\n/**\n * Account deployment result\n */\nexport interface AccountDeploymentResult {\n  accountAddress: Address;\n  txHash: string;\n  isNewDeployment: boolean;\n}\n\n/**\n * Simple Account Factory implementation\n */\nexport class SimpleAccountFactory {\n  private provider: ethers.Provider;\n  private config: AccountFactoryConfig;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, config: AccountFactoryConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.contract = new ethers.Contract(\n      config.factoryAddress,\n      [\n        'function createAccount(address owner, uint256 salt) returns (address)',\n        'function getAddress(address owner, uint256 salt) view returns (address)',\n      ],\n      provider\n    );\n  }\n\n  /**\n   * Calculate the counterfactual address for a simple account\n   */\n  async getAccountAddress(owner: Address, salt: bigint): Promise<Address> {\n    try {\n      const result = await this.contract.getFunction('getAddress')(owner, salt);\n      return result as Address;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get account address',\n        { error, owner, salt }\n      );\n    }\n  }\n\n  /**\n   * Deploy a new simple account\n   */\n  async deployAccount(\n    owner: Address,\n    salt: bigint,\n    signer?: ethers.Wallet\n  ): Promise<AccountDeploymentResult> {\n    try {\n      // First check if account already exists\n      const accountAddress = await this.getAccountAddress(owner, salt);\n      const code = await this.provider.getCode(accountAddress);\n      \n      if (code !== '0x') {\n        // Account already deployed\n        return {\n          accountAddress,\n          txHash: '',\n          isNewDeployment: false,\n        };\n      }\n\n      // Deploy new account\n      if (!signer) {\n        throw new ContractError('Signer required for deployment');\n      }\n\n      const factoryWithSigner = this.contract.connect(signer);\n      const tx = await factoryWithSigner.getFunction('createAccount')(owner, salt);\n      await tx.wait();\n\n      return {\n        accountAddress,\n        txHash: tx.hash,\n        isNewDeployment: true,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy account',\n        { error, owner, salt }\n      );\n    }\n  }\n\n  /**\n   * Create a SimpleAccount instance\n   */\n  createAccountInstance(accountAddress: Address): SimpleAccount {\n    return new SimpleAccount(\n      this.provider,\n      accountAddress,\n      this.config.entryPointAddress\n    );\n  }\n\n  /**\n   * Get the init code for account deployment\n   */\n  async getInitCode(owner: Address, salt: bigint): Promise<HexString> {\n    try {\n      const initCallData = this.contract.interface.encodeFunctionData(\n        'createAccount',\n        [owner, salt]\n      );\n\n      return `${this.config.factoryAddress}${initCallData.slice(2)}` as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get init code',\n        { error, owner, salt }\n      );\n    }\n  }\n}\n\n/**\n * Multi-Sig Account Factory implementation\n */\nexport class MultiSigAccountFactory {\n  private provider: ethers.Provider;\n  private config: AccountFactoryConfig;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, config: AccountFactoryConfig) {\n    this.provider = provider;\n    this.config = config;\n    this.contract = new ethers.Contract(\n      config.factoryAddress,\n      [\n        'function createAccount(address[] owners, uint256 threshold, uint256 salt) returns (address)',\n        'function getAddress(address[] owners, uint256 threshold, uint256 salt) view returns (address)',\n      ],\n      provider\n    );\n  }\n\n  /**\n   * Calculate the counterfactual address for a multi-sig account\n   */\n  async getAccountAddress(\n    owners: Address[],\n    threshold: number,\n    salt: bigint\n  ): Promise<Address> {\n    try {\n      const result = await this.contract.getFunction('getAddress')(owners, threshold, salt);\n      return result as Address;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get multi-sig account address',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n\n  /**\n   * Deploy a new multi-sig account\n   */\n  async deployAccount(\n    owners: Address[],\n    threshold: number,\n    salt: bigint,\n    signer?: ethers.Wallet\n  ): Promise<AccountDeploymentResult> {\n    try {\n      // Validate inputs\n      if (owners.length === 0) {\n        throw new ContractError('At least one owner required');\n      }\n      if (threshold > owners.length) {\n        throw new ContractError('Threshold cannot exceed number of owners');\n      }\n      if (threshold === 0) {\n        throw new ContractError('Threshold must be greater than 0');\n      }\n\n      // Check if account already exists\n      const accountAddress = await this.getAccountAddress(owners, threshold, salt);\n      const code = await this.provider.getCode(accountAddress);\n      \n      if (code !== '0x') {\n        return {\n          accountAddress,\n          txHash: '',\n          isNewDeployment: false,\n        };\n      }\n\n      // Deploy new account\n      if (!signer) {\n        throw new ContractError('Signer required for deployment');\n      }\n\n      const factoryWithSigner = this.contract.connect(signer);\n      const tx = await factoryWithSigner.getFunction('createAccount')(owners, threshold, salt);\n      await tx.wait();\n\n      return {\n        accountAddress,\n        txHash: tx.hash,\n        isNewDeployment: true,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deploy multi-sig account',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n\n  /**\n   * Create a MultiSigAccount instance\n   */\n  createAccountInstance(\n    accountAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ): MultiSigAccount {\n    return new MultiSigAccount(\n      this.provider,\n      accountAddress,\n      this.config.entryPointAddress,\n      threshold,\n      signers\n    );\n  }\n\n  /**\n   * Get the init code for multi-sig account deployment\n   */\n  async getInitCode(\n    owners: Address[],\n    threshold: number,\n    salt: bigint\n  ): Promise<HexString> {\n    try {\n      const initCallData = this.contract.interface.encodeFunctionData(\n        'createAccount',\n        [owners, threshold, salt]\n      );\n\n      return `${this.config.factoryAddress}${initCallData.slice(2)}` as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get multi-sig init code',\n        { error, owners, threshold, salt }\n      );\n    }\n  }\n}\n\n/**\n * Factory manager for creating different types of account factories\n */\nexport class AccountFactoryManager {\n  private provider: ethers.Provider;\n\n  constructor(provider: ethers.Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Create a SimpleAccountFactory instance\n   */\n  createSimpleAccountFactory(config: AccountFactoryConfig): SimpleAccountFactory {\n    return new SimpleAccountFactory(this.provider, config);\n  }\n\n  /**\n   * Create a MultiSigAccountFactory instance\n   */\n  createMultiSigAccountFactory(config: AccountFactoryConfig): MultiSigAccountFactory {\n    return new MultiSigAccountFactory(this.provider, config);\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError } from '../types';\nimport type { UserOperation, Address, HexString } from '../types';\nimport { ENTRY_POINT_ABI } from './types';\n\n/**\n * EntryPoint client for ERC-4337 operations\n */\nexport class EntryPointClient {\n  private provider: ethers.Provider;\n  private address: Address;\n  private contract: ethers.Contract;\n\n  constructor(provider: ethers.Provider, address: Address) {\n    this.provider = provider;\n    this.address = address;\n    this.contract = new ethers.Contract(address, ENTRY_POINT_ABI, provider);\n  }\n\n  /**\n   * Get the EntryPoint contract address\n   */\n  getAddress(): Address {\n    return this.address;\n  }\n\n  /**\n   * Calculate the hash of a UserOperation\n   */\n  async getUserOpHash(userOp: UserOperation): Promise<HexString> {\n    try {\n      const result = await this.contract.getFunction('getUserOpHash')(userOp);\n      return result as HexString;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get UserOperation hash',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Handle a batch of UserOperations (submit to bundler)\n   */\n  async handleOps(\n    userOps: UserOperation[],\n    beneficiary: Address,\n    signer: ethers.Wallet\n  ): Promise<string> {\n    try {\n      const contractWithSigner = this.contract.connect(signer);\n      const tx = await contractWithSigner.getFunction('handleOps')(userOps, beneficiary);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to handle UserOperations',\n        { error, userOps, beneficiary }\n      );\n    }\n  }\n\n  /**\n   * Simulate a UserOperation to check for validation errors\n   */\n  async simulateValidation(userOp: UserOperation): Promise<{\n    preOpGas: bigint;\n    prefund: bigint;\n    sigFailed: boolean;\n    validAfter: number;\n    validUntil: number;\n  }> {\n    try {\n      // In a real implementation, this would call simulateValidation\n      // For now, we'll return mock data\n      return {\n        preOpGas: 50000n,\n        prefund: userOp.callGasLimit * userOp.maxFeePerGas,\n        sigFailed: false,\n        validAfter: 0,\n        validUntil: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to simulate validation',\n        { error, userOp }\n      );\n    }\n  }\n\n  /**\n   * Get the deposit balance for an account\n   */\n  async balanceOf(account: Address): Promise<bigint> {\n    try {\n      const balanceContract = new ethers.Contract(\n        this.address,\n        ['function balanceOf(address) view returns (uint256)'],\n        this.provider\n      );\n      const result = await balanceContract.getFunction('balanceOf')(account);\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get balance',\n        { error, account }\n      );\n    }\n  }\n\n  /**\n   * Deposit ETH for an account\n   */\n  async depositTo(account: Address, amount: bigint, signer: ethers.Wallet): Promise<string> {\n    try {\n      const depositContract = new ethers.Contract(\n        this.address,\n        ['function depositTo(address) payable'],\n        signer\n      );\n      const tx = await depositContract.getFunction('depositTo')(account, { value: amount });\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to deposit',\n        { error, account, amount }\n      );\n    }\n  }\n\n  /**\n   * Withdraw ETH from an account's deposit\n   */\n  async withdrawTo(\n    withdrawAddress: Address,\n    amount: bigint,\n    signer: ethers.Wallet\n  ): Promise<string> {\n    try {\n      const withdrawContract = new ethers.Contract(\n        this.address,\n        ['function withdrawTo(address, uint256)'],\n        signer\n      );\n      const tx = await withdrawContract.getFunction('withdrawTo')(withdrawAddress, amount);\n      return tx.hash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to withdraw',\n        { error, withdrawAddress, amount }\n      );\n    }\n  }\n\n  /**\n   * Get the nonce for an account\n   */\n  async getNonce(account: Address, key: bigint = 0n): Promise<bigint> {\n    try {\n      const nonceContract = new ethers.Contract(\n        this.address,\n        ['function getNonce(address, uint192) view returns (uint256)'],\n        this.provider\n      );\n      const result = await nonceContract.getFunction('getNonce')(account, key);\n      return result as bigint;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to get nonce',\n        { error, account, key }\n      );\n    }\n  }\n\n  /**\n   * Check if an operation is valid\n   */\n  async validateUserOp(userOp: UserOperation): Promise<boolean> {\n    try {\n      // Perform basic validation checks\n      if (!userOp.sender || !ethers.isAddress(userOp.sender)) {\n        return false;\n      }\n\n      if (userOp.nonce < 0n) {\n        return false;\n      }\n\n      if (userOp.callGasLimit < 0n || userOp.verificationGasLimit < 0n) {\n        return false;\n      }\n\n      // Additional validation logic can be added here\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Estimate gas for a UserOperation\n   */\n  async estimateUserOpGas(userOp: UserOperation): Promise<{\n    callGasLimit: bigint;\n    verificationGasLimit: bigint;\n    preVerificationGas: bigint;\n  }> {\n    try {\n      // In a real implementation, this would call the EntryPoint's estimation methods\n      // For now, we'll provide reasonable estimates\n      const baseGas = 21000n;\n      const callDataGas = BigInt(userOp.callData.length - 2) * 16n / 2n; // Rough estimate\n      \n      return {\n        callGasLimit: baseGas + callDataGas + 50000n,\n        verificationGasLimit: 100000n,\n        preVerificationGas: 21000n,\n      };\n    } catch (error) {\n      throw new ContractError(\n        'Failed to estimate gas',\n        { error, userOp }\n      );\n    }\n  }\n} ","import { ethers } from 'ethers';\nimport { ContractError, ConfigError } from '../types';\nimport type { \n  UserOperation, \n  TransactionData, \n  BatchTransaction,\n  Address, \n  HexString,\n  NetworkConfig,\n} from '../types';\nimport { SimpleAccount, MultiSigAccount } from './account';\nimport { VerifyingPaymaster, PaymasterFactory } from './paymaster';\nimport { SimpleAccountFactory, MultiSigAccountFactory, AccountFactoryManager } from './factory';\nimport { EntryPointClient } from './entrypoint';\nimport { DEFAULT_CONTRACT_ADDRESSES } from './types';\n\n/**\n * Configuration for the contracts client\n */\nexport interface ContractsClientConfig {\n  network: NetworkConfig;\n  entryPointAddress?: Address;\n  simpleAccountFactoryAddress?: Address;\n  multiSigAccountFactoryAddress?: Address;\n  verifyingPaymasterAddress?: Address;\n  signer?: ethers.Wallet;\n}\n\n/**\n * Main contracts client that provides a unified interface for all contract operations\n */\nexport class ContractsClient {\n  private provider: ethers.Provider;\n  private config: ContractsClientConfig;\n  private entryPoint: EntryPointClient;\n  private accountFactoryManager: AccountFactoryManager;\n  private paymasterFactory: PaymasterFactory;\n  private signer?: ethers.Wallet;\n\n  constructor(config: ContractsClientConfig) {\n    this.config = config;\n    this.provider = new ethers.JsonRpcProvider(config.network.rpcUrl);\n    \n    if (config.signer) {\n      this.signer = config.signer.connect(this.provider);\n    }\n\n    // Initialize EntryPoint\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    this.entryPoint = new EntryPointClient(this.provider, entryPointAddress);\n\n    // Initialize factories\n    this.accountFactoryManager = new AccountFactoryManager(this.provider);\n    this.paymasterFactory = new PaymasterFactory(this.provider);\n  }\n\n  /**\n   * Get contract address for the current network\n   */\n  private getContractAddress(contractType: string): Address {\n    const chainId = this.config.network.chainId;\n    const addresses = DEFAULT_CONTRACT_ADDRESSES[chainId];\n    \n    if (!addresses) {\n      throw new ConfigError(\n        `No contract addresses configured for chain ID ${chainId}`\n      );\n    }\n\n    // Check for custom addresses in config first\n    switch (contractType) {\n      case 'entryPoint':\n        return this.config.entryPointAddress ?? addresses.entryPoint;\n      case 'simpleAccountFactory':\n        return this.config.simpleAccountFactoryAddress ?? addresses.simpleAccountFactory;\n      case 'multiSigAccountFactory':\n        return this.config.multiSigAccountFactoryAddress ?? addresses.multiSigAccountFactory;\n      case 'verifyingPaymaster':\n        return this.config.verifyingPaymasterAddress ?? addresses.verifyingPaymaster;\n      default:\n        throw new ConfigError(`Unknown contract type: ${contractType}`);\n    }\n  }\n\n  /**\n   * Create a simple account factory\n   */\n  createSimpleAccountFactory(): SimpleAccountFactory {\n    const factoryAddress = this.getContractAddress('simpleAccountFactory');\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    \n    return this.accountFactoryManager.createSimpleAccountFactory({\n      factoryAddress,\n      entryPointAddress,\n      implementationAddress: factoryAddress, // Simplified for demo\n    });\n  }\n\n  /**\n   * Create a multi-sig account factory\n   */\n  createMultiSigAccountFactory(): MultiSigAccountFactory {\n    const factoryAddress = this.getContractAddress('multiSigAccountFactory');\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    \n    return this.accountFactoryManager.createMultiSigAccountFactory({\n      factoryAddress,\n      entryPointAddress,\n      implementationAddress: factoryAddress, // Simplified for demo\n    });\n  }\n\n  /**\n   * Create a verifying paymaster\n   */\n  createVerifyingPaymaster(signer: ethers.Wallet): VerifyingPaymaster {\n    if (!signer) {\n      throw new ConfigError('Signer required for paymaster operations');\n    }\n\n    const paymasterAddress = this.getContractAddress('verifyingPaymaster');\n    \n    return this.paymasterFactory.createVerifyingPaymaster({\n      address: paymasterAddress,\n      signer: signer.connect(this.provider),\n      validUntil: Math.floor(Date.now() / 1000) + 3600, // 1 hour\n      validAfter: Math.floor(Date.now() / 1000) - 60, // 1 minute ago\n    });\n  }\n\n  /**\n   * Deploy a new simple account\n   */\n  async deploySimpleAccount(\n    owner: Address,\n    salt: bigint = 0n\n  ): Promise<SimpleAccount> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for account deployment');\n    }\n\n    const factory = this.createSimpleAccountFactory();\n    const result = await factory.deployAccount(owner, salt, this.signer);\n    \n    return factory.createAccountInstance(result.accountAddress);\n  }\n\n  /**\n   * Deploy a new multi-sig account\n   */\n  async deployMultiSigAccount(\n    owners: Address[],\n    threshold: number,\n    salt: bigint = 0n\n  ): Promise<MultiSigAccount> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for account deployment');\n    }\n\n    const factory = this.createMultiSigAccountFactory();\n    const result = await factory.deployAccount(owners, threshold, salt, this.signer);\n    \n    return factory.createAccountInstance(result.accountAddress, threshold, owners);\n  }\n\n  /**\n   * Get an existing simple account instance\n   */\n  getSimpleAccount(accountAddress: Address): SimpleAccount {\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    return new SimpleAccount(this.provider, accountAddress, entryPointAddress);\n  }\n\n  /**\n   * Get an existing multi-sig account instance\n   */\n  getMultiSigAccount(\n    accountAddress: Address,\n    threshold: number,\n    signers: Address[]\n  ): MultiSigAccount {\n    const entryPointAddress = this.getContractAddress('entryPoint');\n    return new MultiSigAccount(\n      this.provider,\n      accountAddress,\n      entryPointAddress,\n      threshold,\n      signers\n    );\n  }\n\n  /**\n   * Execute a transaction through an account\n   */\n  async executeTransaction(\n    account: SimpleAccount | MultiSigAccount,\n    transaction: TransactionData,\n    signature: HexString,\n    usePaymaster: boolean = false\n  ): Promise<string> {\n    try {\n      let userOp = await account.buildUserOperation(transaction);\n\n      // Add paymaster data if requested\n      if (usePaymaster && this.signer) {\n        const paymaster = this.createVerifyingPaymaster(this.signer);\n        const paymasterData = await paymaster.generatePaymasterData(userOp);\n        userOp.paymasterAndData = paymasterData;\n      }\n\n      // Set signature\n      userOp.signature = signature;\n\n      // Submit to EntryPoint (in real implementation, this would go through a bundler)\n      if (!this.signer) {\n        throw new ConfigError('Signer required for transaction execution');\n      }\n\n      return await this.entryPoint.handleOps([userOp], this.signer.address as Address, this.signer);\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute transaction',\n        { error, transaction }\n      );\n    }\n  }\n\n  /**\n   * Execute a batch of transactions\n   */\n  async executeBatchTransaction(\n    account: SimpleAccount | MultiSigAccount,\n    batch: BatchTransaction,\n    signature: HexString,\n    usePaymaster: boolean = false\n  ): Promise<string> {\n    try {\n      // For batch transactions, paymaster support would need to be implemented\n      // at the account level. For now, we acknowledge the parameter.\n      if (usePaymaster && !this.signer) {\n        throw new ConfigError('Signer required for paymaster operations');\n      }\n      \n      const result = await account.executeBatch(batch, signature);\n      return result.txHash;\n    } catch (error) {\n      throw new ContractError(\n        'Failed to execute batch transaction',\n        { error, batch }\n      );\n    }\n  }\n\n  /**\n   * Estimate gas for a user operation\n   */\n  async estimateUserOpGas(userOp: UserOperation): Promise<{\n    callGasLimit: bigint;\n    verificationGasLimit: bigint;\n    preVerificationGas: bigint;\n  }> {\n    return this.entryPoint.estimateUserOpGas(userOp);\n  }\n\n  /**\n   * Get the hash of a user operation\n   */\n  async getUserOpHash(userOp: UserOperation): Promise<HexString> {\n    return this.entryPoint.getUserOpHash(userOp);\n  }\n\n  /**\n   * Validate a user operation\n   */\n  async validateUserOp(userOp: UserOperation): Promise<boolean> {\n    return this.entryPoint.validateUserOp(userOp);\n  }\n\n  /**\n   * Get account balance in the EntryPoint\n   */\n  async getAccountBalance(account: Address): Promise<bigint> {\n    return this.entryPoint.balanceOf(account);\n  }\n\n  /**\n   * Deposit ETH for an account\n   */\n  async depositForAccount(account: Address, amount: bigint): Promise<string> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for deposits');\n    }\n    return this.entryPoint.depositTo(account, amount, this.signer);\n  }\n\n  /**\n   * Withdraw ETH from an account\n   */\n  async withdrawFromAccount(\n    withdrawAddress: Address,\n    amount: bigint\n  ): Promise<string> {\n    if (!this.signer) {\n      throw new ConfigError('Signer required for withdrawals');\n    }\n    return this.entryPoint.withdrawTo(withdrawAddress, amount, this.signer);\n  }\n\n  /**\n   * Get the current network configuration\n   */\n  getNetworkConfig(): NetworkConfig {\n    return this.config.network;\n  }\n\n  /**\n   * Update the signer\n   */\n  updateSigner(signer: ethers.Wallet): void {\n    this.signer = signer.connect(this.provider);\n  }\n\n  /**\n   * Get the EntryPoint client\n   */\n  getEntryPoint(): EntryPointClient {\n    return this.entryPoint;\n  }\n} ","import { ethers } from 'ethers';\nimport type { Address, HexString, UserOperation } from '../types';\n\n/**\n * Validate if a string is a valid Ethereum address\n */\nexport function isValidAddress(address: string): address is Address {\n  // Must start with 0x and be exactly 42 characters\n  if (!address.startsWith('0x') || address.length !== 42) {\n    return false;\n  }\n  return ethers.isAddress(address);\n}\n\n/**\n * Validate if a string is a valid hex string\n */\nexport function isValidHexString(hex: string): hex is HexString {\n  return /^0x[a-fA-F0-9]*$/.test(hex);\n}\n\n/**\n * Validate if a hex string has the correct length for a specific type\n */\nexport function isValidHexLength(hex: string, expectedLength: number): boolean {\n  if (!isValidHexString(hex)) return false;\n  return hex.length === 2 + expectedLength * 2; // 2 for '0x' + 2 chars per byte\n}\n\n/**\n * Validate if a string is a valid transaction hash\n */\nexport function isValidTxHash(hash: string): boolean {\n  return isValidHexLength(hash, 32);\n}\n\n/**\n * Validate if a string is a valid signature\n */\nexport function isValidSignature(signature: string): boolean {\n  return isValidHexLength(signature, 65); // 65 bytes for ECDSA signature\n}\n\n/**\n * Validate if a UserOperation has all required fields\n */\nexport function isValidUserOperation(userOp: Partial<UserOperation>): userOp is UserOperation {\n  const requiredFields: (keyof UserOperation)[] = [\n    'sender',\n    'nonce',\n    'initCode',\n    'callData',\n    'callGasLimit',\n    'verificationGasLimit',\n    'preVerificationGas',\n    'maxFeePerGas',\n    'maxPriorityFeePerGas',\n    'paymasterAndData',\n    'signature',\n  ];\n\n  for (const field of requiredFields) {\n    if (userOp[field] === undefined || userOp[field] === null) {\n      return false;\n    }\n  }\n\n  // Validate specific field types\n  if (!isValidAddress(userOp.sender!)) return false;\n  if (typeof userOp.nonce !== 'bigint') return false;\n  if (!isValidHexString(userOp.initCode!)) return false;\n  if (!isValidHexString(userOp.callData!)) return false;\n  if (!isValidHexString(userOp.paymasterAndData!)) return false;\n  if (!isValidHexString(userOp.signature!)) return false;\n\n  // Validate gas values are positive\n  if (userOp.callGasLimit! < 0n) return false;\n  if (userOp.verificationGasLimit! < 0n) return false;\n  if (userOp.preVerificationGas! < 0n) return false;\n  if (userOp.maxFeePerGas! < 0n) return false;\n  if (userOp.maxPriorityFeePerGas! < 0n) return false;\n\n  return true;\n}\n\n/**\n * Validate if a chain ID is supported\n */\nexport function isSupportedChainId(chainId: number): boolean {\n  const supportedChains = [1, 11155111, 137, 80001, 42161, 421614, 10, 11155420];\n  return supportedChains.includes(chainId);\n}\n\n/**\n * Validate if a URL is valid\n */\nexport function isValidUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate if a private key is valid\n */\nexport function isValidPrivateKey(privateKey: string): boolean {\n  // Must start with 0x and be exactly 66 characters (64 hex + 0x)\n  if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\n    return false;\n  }\n  \n  // Must be valid hex\n  if (!/^0x[a-fA-F0-9]{64}$/.test(privateKey)) {\n    return false;\n  }\n  \n  try {\n    new ethers.Wallet(privateKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate if a mnemonic phrase is valid\n */\nexport function isValidMnemonic(mnemonic: string): boolean {\n  try {\n    ethers.Mnemonic.fromPhrase(mnemonic);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate if an amount is a valid positive number\n */\nexport function isValidAmount(amount: bigint): boolean {\n  return amount >= 0n;\n}\n\n/**\n * Validate if a gas limit is reasonable\n */\nexport function isValidGasLimit(gasLimit: bigint): boolean {\n  const MIN_GAS = 21000n;\n  const MAX_GAS = 30000000n; // 30M gas limit\n  return gasLimit >= MIN_GAS && gasLimit <= MAX_GAS;\n}\n\n/**\n * Validate if a gas price is reasonable\n */\nexport function isValidGasPrice(gasPrice: bigint): boolean {\n  const MIN_GAS_PRICE = 1n; // 1 wei\n  const MAX_GAS_PRICE = 1000000000000n; // 1000 gwei\n  return gasPrice >= MIN_GAS_PRICE && gasPrice <= MAX_GAS_PRICE;\n}\n\n/**\n * Validate if a threshold is valid for multi-sig\n */\nexport function isValidThreshold(threshold: number, totalSigners: number): boolean {\n  return threshold > 0 && threshold <= totalSigners;\n}\n\n/**\n * Validate if an array of addresses contains only unique valid addresses\n */\nexport function areValidUniqueAddresses(addresses: string[]): addresses is Address[] {\n  if (addresses.length === 0) return false;\n  \n  const uniqueAddresses = new Set(addresses.map(addr => addr.toLowerCase()));\n  if (uniqueAddresses.size !== addresses.length) return false; // Duplicates found\n  \n  return addresses.every(isValidAddress);\n}\n\n/**\n * Validate if a salt value is valid\n */\nexport function isValidSalt(salt: bigint): boolean {\n  return salt >= 0n;\n}\n\n/**\n * Comprehensive validation for account deployment parameters\n */\nexport function validateAccountDeployment(params: {\n  owner?: string;\n  owners?: string[];\n  threshold?: number;\n  salt?: bigint;\n}): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  // Validate single owner (for simple accounts)\n  if (params.owner && !isValidAddress(params.owner)) {\n    errors.push('Invalid owner address');\n  }\n\n  // Validate multiple owners (for multi-sig accounts)\n  if (params.owners) {\n    if (!areValidUniqueAddresses(params.owners)) {\n      errors.push('Invalid or duplicate owner addresses');\n    }\n    \n    if (params.threshold && !isValidThreshold(params.threshold, params.owners.length)) {\n      errors.push('Invalid threshold for number of owners');\n    }\n  }\n\n  // Validate salt\n  if (params.salt !== undefined && !isValidSalt(params.salt)) {\n    errors.push('Invalid salt value');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n} ","import { ethers } from 'ethers';\nimport type { Address, HexString } from '../types';\n\n/**\n * Format an address for display (checksum format)\n */\nexport function formatAddress(address: string): Address {\n  return ethers.getAddress(address) as Address;\n}\n\n/**\n * Truncate an address for display (0x1234...5678)\n */\nexport function truncateAddress(address: string, startChars: number = 6, endChars: number = 4): string {\n  if (address.length <= startChars + endChars) {\n    return address;\n  }\n  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;\n}\n\n/**\n * Format a hex string to ensure proper 0x prefix\n */\nexport function formatHexString(hex: string): HexString {\n  if (!hex.startsWith('0x')) {\n    return `0x${hex}` as HexString;\n  }\n  return hex as HexString;\n}\n\n/**\n * Format wei amount to ether string\n */\nexport function formatEther(wei: bigint, decimals: number = 4): string {\n  return parseFloat(ethers.formatEther(wei)).toFixed(decimals);\n}\n\n/**\n * Format wei amount to gwei string\n */\nexport function formatGwei(wei: bigint, decimals: number = 2): string {\n  return parseFloat(ethers.formatUnits(wei, 'gwei')).toFixed(decimals);\n}\n\n/**\n * Parse ether string to wei\n */\nexport function parseEther(ether: string): bigint {\n  return ethers.parseEther(ether);\n}\n\n/**\n * Parse gwei string to wei\n */\nexport function parseGwei(gwei: string): bigint {\n  return ethers.parseUnits(gwei, 'gwei');\n}\n\n/**\n * Format a large number with appropriate units (K, M, B)\n */\nexport function formatLargeNumber(num: number): string {\n  if (num >= 1e9) {\n    return `${(num / 1e9).toFixed(2)}B`;\n  }\n  if (num >= 1e6) {\n    return `${(num / 1e6).toFixed(2)}M`;\n  }\n  if (num >= 1e3) {\n    return `${(num / 1e3).toFixed(2)}K`;\n  }\n  return num.toString();\n}\n\n/**\n * Format a timestamp to a readable date string\n */\nexport function formatTimestamp(timestamp: number): string {\n  return new Date(timestamp * 1000).toLocaleString();\n}\n\n/**\n * Format a duration in seconds to human readable format\n */\nexport function formatDuration(seconds: number): string {\n  if (seconds < 60) {\n    return `${seconds}s`;\n  }\n  if (seconds < 3600) {\n    return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;\n  }\n  if (seconds < 86400) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    return `${hours}h ${minutes}m`;\n  }\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  return `${days}d ${hours}h`;\n}\n\n/**\n * Format gas amount with appropriate units\n */\nexport function formatGas(gas: bigint): string {\n  const gasNumber = Number(gas);\n  if (gasNumber >= 1e6) {\n    return `${(gasNumber / 1e6).toFixed(2)}M`;\n  }\n  if (gasNumber >= 1e3) {\n    return `${(gasNumber / 1e3).toFixed(2)}K`;\n  }\n  return gasNumber.toString();\n}\n\n/**\n * Format a percentage with specified decimal places\n */\nexport function formatPercentage(value: number, decimals: number = 2): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Format bytes to human readable format\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  \n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n}\n\n/**\n * Format a transaction hash for display\n */\nexport function formatTxHash(hash: string, startChars: number = 10, endChars: number = 8): string {\n  return truncateAddress(hash, startChars, endChars);\n}\n\n/**\n * Format a chain ID to network name\n */\nexport function formatChainId(chainId: number): string {\n  const networks: Record<number, string> = {\n    1: 'Ethereum Mainnet',\n    11155111: 'Ethereum Sepolia',\n    137: 'Polygon Mainnet',\n    80001: 'Polygon Mumbai',\n    42161: 'Arbitrum One',\n    421614: 'Arbitrum Sepolia',\n    10: 'Optimism Mainnet',\n    11155420: 'Optimism Sepolia',\n  };\n  \n  return networks[chainId] ?? `Chain ${chainId}`;\n}\n\n/**\n * Format a UserOperation for logging/display\n */\nexport function formatUserOperation(userOp: any): string {\n  return JSON.stringify({\n    sender: truncateAddress(userOp.sender),\n    nonce: userOp.nonce.toString(),\n    callData: truncateAddress(userOp.callData, 10, 10),\n    callGasLimit: formatGas(userOp.callGasLimit),\n    verificationGasLimit: formatGas(userOp.verificationGasLimit),\n    maxFeePerGas: formatGwei(userOp.maxFeePerGas),\n    signature: userOp.signature ? truncateAddress(userOp.signature, 10, 10) : 'none',\n  }, null, 2);\n}\n\n/**\n * Pad a hex string to a specific length\n */\nexport function padHex(hex: string, length: number): HexString {\n  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;\n  const padded = cleanHex.padStart(length * 2, '0');\n  return `0x${padded}` as HexString;\n}\n\n/**\n * Convert a number to hex string\n */\nexport function numberToHex(num: number | bigint): HexString {\n  return `0x${num.toString(16)}` as HexString;\n}\n\n/**\n * Convert hex string to number\n */\nexport function hexToNumber(hex: string): number {\n  return parseInt(hex, 16);\n}\n\n/**\n * Format an error message for display\n */\nexport function formatError(error: unknown): string {\n  if (error instanceof Error) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return 'Unknown error occurred';\n} ","import { ethers } from 'ethers';\nimport { sha256 } from '@noble/hashes/sha256';\nimport type { Address, HexString } from '../types';\n\n/**\n * Generate a random private key\n */\nexport function generatePrivateKey(): string {\n  return ethers.Wallet.createRandom().privateKey;\n}\n\n/**\n * Generate a random mnemonic phrase\n */\nexport function generateMnemonic(): string {\n  return ethers.Wallet.createRandom().mnemonic?.phrase ?? '';\n}\n\n/**\n * Derive an address from a private key\n */\nexport function privateKeyToAddress(privateKey: string): Address {\n  const wallet = new ethers.Wallet(privateKey);\n  return wallet.address as Address;\n}\n\n/**\n * Derive an address from a public key\n */\nexport function publicKeyToAddress(publicKey: string): Address {\n  return ethers.computeAddress(publicKey) as Address;\n}\n\n/**\n * Sign a message with a private key\n */\nexport async function signMessage(\n  message: string | Uint8Array,\n  privateKey: string\n): Promise<HexString> {\n  const wallet = new ethers.Wallet(privateKey);\n  return await wallet.signMessage(message) as HexString;\n}\n\n/**\n * Verify a signature against a message and address\n */\nexport function verifySignature(\n  message: string | Uint8Array,\n  signature: string,\n  address: string\n): boolean {\n  try {\n    const recoveredAddress = ethers.verifyMessage(message, signature);\n    return recoveredAddress.toLowerCase() === address.toLowerCase();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Recover the address from a signature\n */\nexport function recoverAddress(\n  message: string | Uint8Array,\n  signature: string\n): Address {\n  return ethers.verifyMessage(message, signature) as Address;\n}\n\n/**\n * Hash data using SHA256\n */\nexport function hashSHA256(data: Uint8Array): Uint8Array {\n  return sha256(data);\n}\n\n/**\n * Hash data using Keccak256 (Ethereum's hash function)\n */\nexport function hashKeccak256(data: string | Uint8Array): HexString {\n  return ethers.keccak256(data) as HexString;\n}\n\n/**\n * Hash a string using Keccak256\n */\nexport function hashString(str: string): HexString {\n  return ethers.id(str) as HexString;\n}\n\n/**\n * Generate a deterministic salt from input data\n */\nexport function generateSalt(data: string): bigint {\n  const hash = hashString(data);\n  return BigInt(hash);\n}\n\n/**\n * Create a message hash for EIP-712 structured data\n */\nexport function hashTypedData(\n  domain: ethers.TypedDataDomain,\n  types: Record<string, ethers.TypedDataField[]>,\n  value: Record<string, unknown>\n): HexString {\n  return ethers.TypedDataEncoder.hash(domain, types, value) as HexString;\n}\n\n/**\n * Sign EIP-712 structured data\n */\nexport async function signTypedData(\n  privateKey: string,\n  domain: ethers.TypedDataDomain,\n  types: Record<string, ethers.TypedDataField[]>,\n  value: Record<string, unknown>\n): Promise<HexString> {\n  const wallet = new ethers.Wallet(privateKey);\n  return await wallet.signTypedData(domain, types, value) as HexString;\n}\n\n/**\n * Verify EIP-712 structured data signature\n */\nexport function verifyTypedData(\n  domain: ethers.TypedDataDomain,\n  types: Record<string, ethers.TypedDataField[]>,\n  value: Record<string, unknown>,\n  signature: string,\n  address: string\n): boolean {\n  try {\n    const recoveredAddress = ethers.verifyTypedData(domain, types, value, signature);\n    return recoveredAddress.toLowerCase() === address.toLowerCase();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate a random nonce\n */\nexport function generateNonce(): bigint {\n  return BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));\n}\n\n/**\n * Generate a secure random salt\n */\nexport function generateSecureSalt(): bigint {\n  const randomBytes = ethers.randomBytes(32);\n  return BigInt(ethers.hexlify(randomBytes));\n}\n\n/**\n * Derive a child private key from a master private key and path (simplified HD wallet)\n */\nexport function derivePrivateKey(masterKey: string, index: number): string {\n  // This is a simplified derivation - in production, use proper HD wallet derivation\n  const combined = `${masterKey}${index}`;\n  const hash = hashString(combined);\n  return hash;\n}\n\n/**\n * Create a wallet from mnemonic and derivation path\n */\nexport function createWalletFromMnemonic(\n  mnemonic: string,\n  path: string = \"m/44'/60'/0'/0/0\"\n): ethers.Wallet {\n  const hdNode = ethers.HDNodeWallet.fromPhrase(mnemonic, undefined, path);\n  return new ethers.Wallet(hdNode.privateKey);\n}\n\n/**\n * Encrypt a private key with a password\n */\nexport async function encryptPrivateKey(\n  privateKey: string,\n  password: string\n): Promise<string> {\n  const wallet = new ethers.Wallet(privateKey);\n  return await wallet.encrypt(password);\n}\n\n/**\n * Decrypt an encrypted private key with a password\n */\nexport async function decryptPrivateKey(\n  encryptedKey: string,\n  password: string\n): Promise<string> {\n  const wallet = await ethers.Wallet.fromEncryptedJson(encryptedKey, password);\n  return wallet.privateKey;\n}\n\n/**\n * Generate a deterministic address from multiple inputs\n */\nexport function generateDeterministicAddress(\n  factory: Address,\n  salt: bigint,\n  initCodeHash: HexString\n): Address {\n  const packed = ethers.solidityPacked(\n    ['bytes1', 'address', 'uint256', 'bytes32'],\n    ['0xff', factory, salt, initCodeHash]\n  );\n  const hash = hashKeccak256(packed);\n  return `0x${hash.slice(-40)}` as Address;\n}\n\n/**\n * Split a signature into r, s, v components\n */\nexport function splitSignature(signature: string): {\n  r: string;\n  s: string;\n  v: number;\n} {\n  return ethers.Signature.from(signature);\n}\n\n/**\n * Join signature components into a signature string\n */\nexport function joinSignature(r: string, s: string, v: number): HexString {\n  const signature = ethers.Signature.from({ r, s, v });\n  return signature.serialized as HexString;\n}\n\n/**\n * Generate a UserOperation hash for signing\n */\nexport function getUserOpHash(\n  userOp: any,\n  entryPoint: Address,\n  chainId: number\n): HexString {\n  // Simplified UserOperation hash calculation\n  // In production, this should match the EntryPoint contract's hash calculation\n  const packed = ethers.solidityPacked(\n    ['address', 'uint256', 'bytes32', 'bytes32', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'bytes32'],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashKeccak256(userOp.initCode),\n      hashKeccak256(userOp.callData),\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashKeccak256(userOp.paymasterAndData),\n    ]\n  );\n  \n  const opHash = hashKeccak256(packed);\n  \n  // Add entryPoint and chainId\n  const finalPacked = ethers.solidityPacked(\n    ['bytes32', 'address', 'uint256'],\n    [opHash, entryPoint, chainId]\n  );\n  \n  return hashKeccak256(finalPacked);\n} ","import type { Address } from '../types';\n\n// ============================================================================\n// Network Constants\n// ============================================================================\n\n/**\n * Supported blockchain networks\n */\nexport const SUPPORTED_NETWORKS = {\n  ETHEREUM_MAINNET: {\n    chainId: 1,\n    name: 'Ethereum Mainnet',\n    rpcUrl: 'https://mainnet.infura.io/v3/',\n    explorerUrl: 'https://etherscan.io',\n    currency: 'ETH',\n    isTestnet: false,\n  },\n  ETHEREUM_SEPOLIA: {\n    chainId: 11155111,\n    name: 'Ethereum Sepolia',\n    rpcUrl: 'https://sepolia.infura.io/v3/',\n    explorerUrl: 'https://sepolia.etherscan.io',\n    currency: 'ETH',\n    isTestnet: true,\n  },\n  POLYGON_MAINNET: {\n    chainId: 137,\n    name: 'Polygon Mainnet',\n    rpcUrl: 'https://polygon-rpc.com',\n    explorerUrl: 'https://polygonscan.com',\n    currency: 'MATIC',\n    isTestnet: false,\n  },\n  POLYGON_MUMBAI: {\n    chainId: 80001,\n    name: 'Polygon Mumbai',\n    rpcUrl: 'https://rpc-mumbai.maticvigil.com',\n    explorerUrl: 'https://mumbai.polygonscan.com',\n    currency: 'MATIC',\n    isTestnet: true,\n  },\n  ARBITRUM_ONE: {\n    chainId: 42161,\n    name: 'Arbitrum One',\n    rpcUrl: 'https://arb1.arbitrum.io/rpc',\n    explorerUrl: 'https://arbiscan.io',\n    currency: 'ETH',\n    isTestnet: false,\n  },\n  ARBITRUM_SEPOLIA: {\n    chainId: 421614,\n    name: 'Arbitrum Sepolia',\n    rpcUrl: 'https://sepolia-rollup.arbitrum.io/rpc',\n    explorerUrl: 'https://sepolia.arbiscan.io',\n    currency: 'ETH',\n    isTestnet: true,\n  },\n  OPTIMISM_MAINNET: {\n    chainId: 10,\n    name: 'Optimism Mainnet',\n    rpcUrl: 'https://mainnet.optimism.io',\n    explorerUrl: 'https://optimistic.etherscan.io',\n    currency: 'ETH',\n    isTestnet: false,\n  },\n  OPTIMISM_SEPOLIA: {\n    chainId: 11155420,\n    name: 'Optimism Sepolia',\n    rpcUrl: 'https://sepolia.optimism.io',\n    explorerUrl: 'https://sepolia-optimistic.etherscan.io',\n    currency: 'ETH',\n    isTestnet: true,\n  },\n} as const;\n\n// ============================================================================\n// Contract Constants\n// ============================================================================\n\n/**\n * Standard ERC-4337 EntryPoint address (v0.6)\n */\nexport const ENTRYPOINT_ADDRESS_V06: Address = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';\n\n/**\n * Default gas limits for various operations\n */\nexport const GAS_LIMITS = {\n  ACCOUNT_DEPLOYMENT: 1000000n,\n  SIMPLE_EXECUTION: 35000n,\n  MULTI_SIG_EXECUTION: 100000n,\n  VERIFICATION_GAS: 70000n,\n  PRE_VERIFICATION_GAS: 21000n,\n  PAYMASTER_VERIFICATION: 50000n,\n} as const;\n\n/**\n * Gas price constants (in wei)\n */\nexport const GAS_PRICES = {\n  MIN_GAS_PRICE: 1000000000n, // 1 gwei\n  MAX_GAS_PRICE: 1000000000000n, // 1000 gwei\n  DEFAULT_GAS_PRICE: 20000000000n, // 20 gwei\n} as const;\n\n/**\n * Contract addresses for supported networks\n */\nexport const UTILS_CONTRACT_ADDRESSES: Record<number, {\n  entryPoint: Address;\n  accountFactory: Address;\n  multiSigFactory: Address;\n  verifyingPaymaster: Address;\n}> = {\n  // Ethereum Sepolia\n  [SUPPORTED_NETWORKS.ETHEREUM_SEPOLIA.chainId]: {\n    entryPoint: ENTRYPOINT_ADDRESS_V06,\n    accountFactory: '0x9406Cc6185a346906296840746125a0E44976454' as Address,\n    multiSigFactory: '0x000000000000000000000000000000000000dEaD' as Address,\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD' as Address,\n  },\n  // Polygon Mumbai\n  [SUPPORTED_NETWORKS.POLYGON_MUMBAI.chainId]: {\n    entryPoint: ENTRYPOINT_ADDRESS_V06,\n    accountFactory: '0x000000000000000000000000000000000000dEaD' as Address,\n    multiSigFactory: '0x000000000000000000000000000000000000dEaD' as Address,\n    verifyingPaymaster: '0x000000000000000000000000000000000000dEaD' as Address,\n  },\n};\n\n// ============================================================================\n// ZK Proof Constants\n// ============================================================================\n\n/**\n * Zero-knowledge proof system parameters\n */\nexport const UTILS_ZK_CONSTANTS = {\n  DEFAULT_CIRCUIT_K: 14,\n  MIN_CIRCUIT_K: 10,\n  MAX_CIRCUIT_K: 20,\n  MAX_INPUT_SIZE: 1024 * 1024, // 1MB\n  SHA256_HASH_SIZE: 32,\n  TARGET_PROOF_TIME_MS: 500,\n  MAX_PROOF_TIME_MS: 30000,\n  PROOF_CACHE_TTL_MS: 24 * 60 * 60 * 1000, // 24 hours\n} as const;\n\n// ============================================================================\n// Validation Constants\n// ============================================================================\n\n/**\n * Address validation patterns\n */\nexport const VALIDATION_PATTERNS = {\n  ETH_ADDRESS: /^0x[a-fA-F0-9]{40}$/,\n  HEX_STRING: /^0x[a-fA-F0-9]*$/,\n  TX_HASH: /^0x[a-fA-F0-9]{64}$/,\n  PRIVATE_KEY: /^0x[a-fA-F0-9]{64}$/,\n} as const;\n\n/**\n * Limits for various operations\n */\nexport const LIMITS = {\n  MAX_TRANSACTION_SIZE: 128 * 1024, // 128KB\n  MAX_BATCH_SIZE: 100,\n  MAX_SIGNERS: 20,\n  MIN_THRESHOLD: 1,\n  MAX_NONCE: 2n ** 256n - 1n,\n} as const;\n\n// ============================================================================\n// Error Messages\n// ============================================================================\n\n/**\n * Standard error messages\n */\nexport const ERROR_MESSAGES = {\n  INVALID_ADDRESS: 'Invalid Ethereum address',\n  INVALID_SIGNATURE: 'Invalid signature format',\n  INVALID_AMOUNT: 'Amount must be positive',\n  INSUFFICIENT_BALANCE: 'Insufficient balance for operation',\n  NETWORK_NOT_SUPPORTED: 'Network not supported',\n  TRANSACTION_FAILED: 'Transaction execution failed',\n  TIMEOUT_EXCEEDED: 'Operation timeout exceeded',\n  INVALID_CONFIGURATION: 'Invalid configuration provided',\n} as const;\n\n// ============================================================================\n// Time Constants\n// ============================================================================\n\n/**\n * Time-related constants (in seconds)\n */\nexport const TIME = {\n  SECOND: 1,\n  MINUTE: 60,\n  HOUR: 3600,\n  DAY: 86400,\n  WEEK: 604800,\n  MONTH: 2592000, // 30 days\n  YEAR: 31536000, // 365 days\n} as const;\n\n/**\n * Default timeouts (in milliseconds)\n */\nexport const TIMEOUTS = {\n  NETWORK_REQUEST: 10000, // 10 seconds\n  TRANSACTION_CONFIRMATION: 60000, // 1 minute\n  PROOF_GENERATION: 30000, // 30 seconds\n  CONTRACT_DEPLOYMENT: 120000, // 2 minutes\n} as const;\n\n// ============================================================================\n// Feature Flags\n// ============================================================================\n\n/**\n * Feature flags for optional functionality\n */\nexport const FEATURE_FLAGS = {\n  ENABLE_ZK_PROOFS: true,\n  ENABLE_GASLESS_TRANSACTIONS: true,\n  ENABLE_MULTI_SIG: true,\n  ENABLE_SOCIAL_RECOVERY: false, // Future feature\n  ENABLE_BATCH_TRANSACTIONS: true,\n  ENABLE_CROSS_CHAIN: false, // Future feature\n} as const;\n\n// ============================================================================\n// Version Information\n// ============================================================================\n\n/**\n * SDK version and compatibility information\n */\nexport const VERSION_INFO = {\n  SDK_VERSION: '0.1.0',\n  ERC_4337_VERSION: '0.6.0',\n  SUPPORTED_SOLIDITY_VERSION: '^0.8.25',\n  MIN_NODE_VERSION: '18.0.0',\n} as const;\n\n// ============================================================================\n// Development Constants\n// ============================================================================\n\n/**\n * Constants for development and testing\n */\nexport const DEV_CONSTANTS = {\n  LOCAL_CHAIN_ID: 31337,\n  LOCAL_RPC_URL: 'http://127.0.0.1:8545',\n  TEST_PRIVATE_KEY: '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',\n  TEST_MNEMONIC: 'test test test test test test test test test test test junk',\n} as const; ","// ============================================================================\n// Guardian-AA SDK - Main Entry Point\n// ============================================================================\n\n/**\n * Guardian-AA SDK\n * Zero-Knowledge AI Wallet Copilot\n * \n * A comprehensive TypeScript SDK for building applications with Guardian-AA,\n * featuring zero-knowledge proofs, account abstraction, and gasless transactions.\n * \n * @version 0.1.0\n * @author Guardian-AA Team\n * @license MIT\n */\n\n// Re-export all from types (main types)\nexport * from './types';\n\n// Re-export ZK functionality  \nexport * from './zk';\n\n// Re-export contract functionality\nexport * from './contracts';\n\n// Re-export utilities\nexport * from './utils';\n\n// ============================================================================\n// Main SDK Classes\n// ============================================================================\n\nimport { ethers } from 'ethers';\nimport { ZkClient } from './zk/client';\nimport { ContractsClient } from './contracts/client';\nimport type { \n  SdkConfig, \n  NetworkConfig, \n  ZkProofConfig,\n  AccountConfig,\n} from './types';\nimport { ConfigError } from './types';\n\n/**\n * Main Guardian-AA SDK client\n * Provides a unified interface for all Guardian-AA functionality\n */\nexport class GuardianAA {\n  private config: SdkConfig;\n  private zkClient: ZkClient | undefined;\n  private contractsClient: ContractsClient | undefined;\n  private provider: ethers.Provider | undefined;\n  private signer: ethers.Wallet | undefined;\n\n  constructor(config: SdkConfig) {\n    this.config = config;\n    this.validateConfig();\n  }\n\n  /**\n   * Initialize the SDK\n   */\n  async initialize(signer?: ethers.Wallet): Promise<void> {\n    try {\n      // Initialize provider\n      this.provider = new ethers.JsonRpcProvider(this.config.network.rpcUrl);\n      \n      if (signer) {\n        this.signer = signer.connect(this.provider);\n      }\n\n      // Initialize ZK client if enabled\n      if (this.config.zkConfig) {\n        this.zkClient = new ZkClient(this.config.zkConfig);\n        await this.zkClient.initialize();\n      }\n\n      // Initialize contracts client - always initialize but signer is optional\n      this.contractsClient = new ContractsClient({\n        network: this.config.network,\n        ...(this.signer && { signer: this.signer }),\n      });\n\n      if (this.config.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Guardian-AA SDK initialized successfully');\n      }\n    } catch (error) {\n      throw new ConfigError(\n        'Failed to initialize Guardian-AA SDK',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get the ZK client for zero-knowledge proof operations\n   */\n  getZkClient(): ZkClient {\n    if (!this.zkClient) {\n      throw new ConfigError('ZK client not initialized. Ensure zkConfig is provided.');\n    }\n    return this.zkClient;\n  }\n\n  /**\n   * Get the contracts client for blockchain operations\n   */\n  getContractsClient(): ContractsClient {\n    if (!this.contractsClient) {\n      throw new ConfigError('Contracts client not initialized. Call initialize() first.');\n    }\n    return this.contractsClient;\n  }\n\n  /**\n   * Get the current provider\n   */\n  getProvider(): ethers.Provider {\n    if (!this.provider) {\n      throw new ConfigError('Provider not initialized. Call initialize() first.');\n    }\n    return this.provider;\n  }\n\n  /**\n   * Get the current signer\n   */\n  getSigner(): ethers.Wallet {\n    if (!this.signer) {\n      throw new ConfigError('Signer not set. Provide a signer during initialization.');\n    }\n    return this.signer;\n  }\n\n  /**\n   * Update the signer\n   */\n  updateSigner(signer: ethers.Wallet): void {\n    if (this.provider) {\n      this.signer = signer.connect(this.provider);\n      this.contractsClient?.updateSigner(this.signer);\n    } else {\n      this.signer = signer;\n    }\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): SdkConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update the configuration\n   */\n  updateConfig(newConfig: Partial<SdkConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.validateConfig();\n  }\n\n  /**\n   * Check if the SDK is ready for operations\n   */\n  isReady(): boolean {\n    return Boolean(\n      this.provider &&\n      this.contractsClient &&\n      (!this.config.zkConfig || this.zkClient?.isReady())\n    );\n  }\n\n  /**\n   * Cleanup SDK resources\n   */\n  async cleanup(): Promise<void> {\n    if (this.zkClient) {\n      await this.zkClient.cleanup();\n    }\n    this.provider = undefined;\n    this.signer = undefined;\n    this.contractsClient = undefined;\n  }\n\n  /**\n   * Validate the SDK configuration\n   */\n  private validateConfig(): void {\n    if (!this.config.network) {\n      throw new ConfigError('Network configuration is required');\n    }\n\n    if (!this.config.network.rpcUrl) {\n      throw new ConfigError('Network RPC URL is required');\n    }\n\n    if (!this.config.network.chainId) {\n      throw new ConfigError('Network chain ID is required');\n    }\n  }\n}\n\n// ============================================================================\n// Convenience Factory Functions\n// ============================================================================\n\n/**\n * Create a Guardian-AA SDK instance with minimal configuration\n */\nexport function createGuardianAA(\n  network: NetworkConfig,\n  options: {\n    zkConfig?: ZkProofConfig;\n    accountConfig?: AccountConfig;\n    debug?: boolean;\n  } = {}\n): GuardianAA {\n  const config: SdkConfig = {\n    network,\n    zkConfig: options.zkConfig,\n    accountConfig: options.accountConfig,\n    debug: options.debug ?? false,\n  };\n\n  return new GuardianAA(config);\n}\n\n/**\n * Create a Guardian-AA SDK instance for Ethereum Sepolia testnet\n */\nexport function createSepoliaGuardianAA(\n  rpcUrl?: string,\n  options: {\n    zkConfig?: ZkProofConfig;\n    debug?: boolean;\n  } = {}\n): GuardianAA {\n  const network: NetworkConfig = {\n    chainId: 11155111,\n    name: 'Ethereum Sepolia',\n    rpcUrl: rpcUrl ?? 'https://sepolia.infura.io/v3/',\n    explorerUrl: 'https://sepolia.etherscan.io',\n    currency: 'ETH',\n    isTestnet: true,\n  };\n\n  return createGuardianAA(network, options);\n}\n\n/**\n * Create a Guardian-AA SDK instance for local development\n */\nexport function createLocalGuardianAA(\n  rpcUrl: string = 'http://127.0.0.1:8545',\n  options: {\n    zkConfig?: ZkProofConfig;\n    debug?: boolean;\n  } = {}\n): GuardianAA {\n  const network: NetworkConfig = {\n    chainId: 31337,\n    name: 'Local Network',\n    rpcUrl,\n    currency: 'ETH',\n    isTestnet: true,\n  };\n\n  return createGuardianAA(network, { debug: true, ...options });\n}\n\n// ============================================================================\n// Version Information\n// ============================================================================\n\n/**\n * Get SDK version information\n */\nexport function getVersion(): {\n  sdk: string;\n  erc4337: string;\n  solidity: string;\n} {\n  return {\n    sdk: '0.1.0',\n    erc4337: '0.6.0',\n    solidity: '^0.8.25',\n  };\n} "]}